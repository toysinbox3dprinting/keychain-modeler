/* Generated by npm run generate:adapters. Do not edit directly. */
var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// src/core/vendor/csg/src/core/utils.js
var require_utils = __commonJS({
  "src/core/vendor/csg/src/core/utils.js"(exports, module) {
    "use strict";
    function fnNumberSort(a, b) {
      return a - b;
    }
    function fnSortByIndex(a, b) {
      return a.index - b.index;
    }
    var IsFloat = function(n) {
      return !isNaN(n) || n === Infinity || n === -Infinity;
    };
    var solve2Linear = function(a, b, c, d, u, v) {
      let det = a * d - b * c;
      let invdet = 1 / det;
      let x = u * d - b * v;
      let y = -u * c + a * v;
      x *= invdet;
      y *= invdet;
      return [x, y];
    };
    function insertSorted(array, element, comparefunc) {
      let leftbound = 0;
      let rightbound = array.length;
      while (rightbound > leftbound) {
        let testindex = Math.floor((leftbound + rightbound) / 2);
        let testelement = array[testindex];
        let compareresult = comparefunc(element, testelement);
        if (compareresult > 0) {
          leftbound = testindex + 1;
        } else {
          rightbound = testindex;
        }
      }
      array.splice(leftbound, 0, element);
    }
    var interpolateBetween2DPointsForY = function(point1, point2, y) {
      let f1 = y - point1.y;
      let f2 = point2.y - point1.y;
      if (f2 < 0) {
        f1 = -f1;
        f2 = -f2;
      }
      let t;
      if (f1 <= 0) {
        t = 0;
      } else if (f1 >= f2) {
        t = 1;
      } else if (f2 < 1e-10) {
        t = 0.5;
      } else {
        t = f1 / f2;
      }
      let result = point1.x + t * (point2.x - point1.x);
      return result;
    };
    function isCAG(object) {
      if (!("sides" in object)) {
        return false;
      }
      if (!("length" in object.sides)) {
        return false;
      }
      return true;
    }
    function isCSG(object) {
      if (!("polygons" in object)) {
        return false;
      }
      if (!("length" in object.polygons)) {
        return false;
      }
      return true;
    }
    module.exports = {
      fnNumberSort,
      fnSortByIndex,
      IsFloat,
      solve2Linear,
      insertSorted,
      interpolateBetween2DPointsForY,
      isCAG,
      isCSG
    };
  }
});

// src/core/vendor/csg/src/core/math/Vector2.js
var require_Vector2 = __commonJS({
  "src/core/vendor/csg/src/core/math/Vector2.js"(exports, module) {
    "use strict";
    var { IsFloat } = require_utils();
    var Vector2D = function(x, y) {
      if (arguments.length === 2) {
        this._x = parseFloat(x);
        this._y = parseFloat(y);
      } else {
        var ok = true;
        if (arguments.length === 1) {
          if (typeof x === "object") {
            if (x instanceof Vector2D) {
              this._x = x._x;
              this._y = x._y;
            } else if (x instanceof Array) {
              this._x = parseFloat(x[0]);
              this._y = parseFloat(x[1]);
            } else if ("x" in x && "y" in x) {
              this._x = parseFloat(x.x);
              this._y = parseFloat(x.y);
            } else ok = false;
          } else {
            var v = parseFloat(x);
            this._x = v;
            this._y = v;
          }
        } else ok = false;
        if (ok) {
          if (!IsFloat(this._x) || !IsFloat(this._y)) ok = false;
        }
        if (!ok) {
          throw new Error("wrong arguments");
        }
      }
    };
    Vector2D.fromAngle = function(radians) {
      return Vector2D.fromAngleRadians(radians);
    };
    Vector2D.fromAngleDegrees = function(degrees) {
      var radians = Math.PI * degrees / 180;
      return Vector2D.fromAngleRadians(radians);
    };
    Vector2D.fromAngleRadians = function(radians) {
      return Vector2D.Create(Math.cos(radians), Math.sin(radians));
    };
    Vector2D.Create = function(x, y) {
      var result = Object.create(Vector2D.prototype);
      result._x = x;
      result._y = y;
      return result;
    };
    Vector2D.prototype = {
      get x() {
        return this._x;
      },
      get y() {
        return this._y;
      },
      set x(v) {
        throw new Error("Vector2D is immutable");
      },
      set y(v) {
        throw new Error("Vector2D is immutable");
      },
      // extend to a 3D vector by adding a z coordinate:
      toVector3D: function(z) {
        const Vector3D = require_Vector3();
        return new Vector3D(this._x, this._y, z);
      },
      equals: function(a) {
        return this._x === a._x && this._y === a._y;
      },
      clone: function() {
        return Vector2D.Create(this._x, this._y);
      },
      negated: function() {
        return Vector2D.Create(-this._x, -this._y);
      },
      plus: function(a) {
        return Vector2D.Create(this._x + a._x, this._y + a._y);
      },
      minus: function(a) {
        return Vector2D.Create(this._x - a._x, this._y - a._y);
      },
      times: function(a) {
        return Vector2D.Create(this._x * a, this._y * a);
      },
      dividedBy: function(a) {
        return Vector2D.Create(this._x / a, this._y / a);
      },
      dot: function(a) {
        return this._x * a._x + this._y * a._y;
      },
      lerp: function(a, t) {
        return this.plus(a.minus(this).times(t));
      },
      length: function() {
        return Math.sqrt(this.dot(this));
      },
      distanceTo: function(a) {
        return this.minus(a).length();
      },
      distanceToSquared: function(a) {
        return this.minus(a).lengthSquared();
      },
      lengthSquared: function() {
        return this.dot(this);
      },
      unit: function() {
        return this.dividedBy(this.length());
      },
      cross: function(a) {
        return this._x * a._y - this._y * a._x;
      },
      // returns the vector rotated by 90 degrees clockwise
      normal: function() {
        return Vector2D.Create(this._y, -this._x);
      },
      // Right multiply by a 4x4 matrix (the vector is interpreted as a row vector)
      // Returns a new Vector2D
      multiply4x4: function(matrix4x4) {
        return matrix4x4.leftMultiply1x2Vector(this);
      },
      transform: function(matrix4x4) {
        return matrix4x4.leftMultiply1x2Vector(this);
      },
      angle: function() {
        return this.angleRadians();
      },
      angleDegrees: function() {
        var radians = this.angleRadians();
        return 180 * radians / Math.PI;
      },
      angleRadians: function() {
        return Math.atan2(this._y, this._x);
      },
      min: function(p) {
        return Vector2D.Create(
          Math.min(this._x, p._x),
          Math.min(this._y, p._y)
        );
      },
      max: function(p) {
        return Vector2D.Create(
          Math.max(this._x, p._x),
          Math.max(this._y, p._y)
        );
      },
      toString: function() {
        return "(" + this._x.toFixed(5) + ", " + this._y.toFixed(5) + ")";
      },
      abs: function() {
        return Vector2D.Create(Math.abs(this._x), Math.abs(this._y));
      }
    };
    module.exports = Vector2D;
  }
});

// src/core/vendor/csg/src/core/math/Vector3.js
var require_Vector3 = __commonJS({
  "src/core/vendor/csg/src/core/math/Vector3.js"(exports, module) {
    "use strict";
    var { IsFloat } = require_utils();
    var Vector2D = require_Vector2();
    var Vector3D = function(x, y, z) {
      if (arguments.length === 3) {
        this._x = parseFloat(x);
        this._y = parseFloat(y);
        this._z = parseFloat(z);
      } else if (arguments.length === 2) {
        this._x = parseFloat(x);
        this._y = parseFloat(y);
        this._z = 0;
      } else {
        var ok = true;
        if (arguments.length === 1) {
          if (typeof x === "object") {
            if (x instanceof Vector3D) {
              this._x = x._x;
              this._y = x._y;
              this._z = x._z;
            } else if (x instanceof Vector2D) {
              this._x = x._x;
              this._y = x._y;
              this._z = 0;
            } else if (x instanceof Array) {
              if (x.length < 2 || x.length > 3) {
                ok = false;
              } else {
                this._x = parseFloat(x[0]);
                this._y = parseFloat(x[1]);
                if (x.length === 3) {
                  this._z = parseFloat(x[2]);
                } else {
                  this._z = 0;
                }
              }
            } else if ("x" in x && "y" in x) {
              this._x = parseFloat(x.x);
              this._y = parseFloat(x.y);
              if ("z" in x) {
                this._z = parseFloat(x.z);
              } else {
                this._z = 0;
              }
            } else if ("_x" in x && "_y" in x) {
              this._x = parseFloat(x._x);
              this._y = parseFloat(x._y);
              if ("_z" in x) {
                this._z = parseFloat(x._z);
              } else {
                this._z = 0;
              }
            } else ok = false;
          } else {
            var v = parseFloat(x);
            this._x = v;
            this._y = v;
            this._z = v;
          }
        } else ok = false;
        if (ok) {
          if (!IsFloat(this._x) || !IsFloat(this._y) || !IsFloat(this._z)) ok = false;
        } else {
          throw new Error("wrong arguments");
        }
      }
    };
    Vector3D.Create = function(x, y, z) {
      var result = Object.create(Vector3D.prototype);
      result._x = x;
      result._y = y;
      result._z = z;
      return result;
    };
    Vector3D.prototype = {
      get x() {
        return this._x;
      },
      get y() {
        return this._y;
      },
      get z() {
        return this._z;
      },
      set x(v) {
        throw new Error("Vector3D is immutable");
      },
      set y(v) {
        throw new Error("Vector3D is immutable");
      },
      set z(v) {
        throw new Error("Vector3D is immutable");
      },
      clone: function() {
        return Vector3D.Create(this._x, this._y, this._z);
      },
      negated: function() {
        return Vector3D.Create(-this._x, -this._y, -this._z);
      },
      abs: function() {
        return Vector3D.Create(Math.abs(this._x), Math.abs(this._y), Math.abs(this._z));
      },
      plus: function(a) {
        return Vector3D.Create(this._x + a._x, this._y + a._y, this._z + a._z);
      },
      minus: function(a) {
        return Vector3D.Create(this._x - a._x, this._y - a._y, this._z - a._z);
      },
      times: function(a) {
        return Vector3D.Create(this._x * a, this._y * a, this._z * a);
      },
      dividedBy: function(a) {
        return Vector3D.Create(this._x / a, this._y / a, this._z / a);
      },
      dot: function(a) {
        return this._x * a._x + this._y * a._y + this._z * a._z;
      },
      lerp: function(a, t) {
        return this.plus(a.minus(this).times(t));
      },
      lengthSquared: function() {
        return this.dot(this);
      },
      length: function() {
        return Math.sqrt(this.lengthSquared());
      },
      unit: function() {
        return this.dividedBy(this.length());
      },
      cross: function(a) {
        return Vector3D.Create(
          this._y * a._z - this._z * a._y,
          this._z * a._x - this._x * a._z,
          this._x * a._y - this._y * a._x
        );
      },
      distanceTo: function(a) {
        return this.minus(a).length();
      },
      distanceToSquared: function(a) {
        return this.minus(a).lengthSquared();
      },
      equals: function(a) {
        return this._x === a._x && this._y === a._y && this._z === a._z;
      },
      // Right multiply by a 4x4 matrix (the vector is interpreted as a row vector)
      // Returns a new Vector3D
      multiply4x4: function(matrix4x4) {
        return matrix4x4.leftMultiply1x3Vector(this);
      },
      transform: function(matrix4x4) {
        return matrix4x4.leftMultiply1x3Vector(this);
      },
      toString: function() {
        return "(" + this._x.toFixed(5) + ", " + this._y.toFixed(5) + ", " + this._z.toFixed(5) + ")";
      },
      // find a vector that is somewhat perpendicular to this one
      randomNonParallelVector: function() {
        var abs = this.abs();
        if (abs._x <= abs._y && abs._x <= abs._z) {
          return Vector3D.Create(1, 0, 0);
        } else if (abs._y <= abs._x && abs._y <= abs._z) {
          return Vector3D.Create(0, 1, 0);
        } else {
          return Vector3D.Create(0, 0, 1);
        }
      },
      min: function(p) {
        return Vector3D.Create(
          Math.min(this._x, p._x),
          Math.min(this._y, p._y),
          Math.min(this._z, p._z)
        );
      },
      max: function(p) {
        return Vector3D.Create(
          Math.max(this._x, p._x),
          Math.max(this._y, p._y),
          Math.max(this._z, p._z)
        );
      }
    };
    module.exports = Vector3D;
  }
});

// src/core/vendor/csg/src/core/math/Line2.js
var require_Line2 = __commonJS({
  "src/core/vendor/csg/src/core/math/Line2.js"(exports, module) {
    "use strict";
    var Vector2D = require_Vector2();
    var { solve2Linear } = require_utils();
    var Line2D = function(normal, w) {
      normal = new Vector2D(normal);
      w = parseFloat(w);
      let l = normal.length();
      w *= l;
      normal = normal.times(1 / l);
      this.normal = normal;
      this.w = w;
    };
    Line2D.fromPoints = function(p1, p2) {
      p1 = new Vector2D(p1);
      p2 = new Vector2D(p2);
      let direction = p2.minus(p1);
      let normal = direction.normal().negated().unit();
      let w = p1.dot(normal);
      return new Line2D(normal, w);
    };
    Line2D.prototype = {
      // same line but opposite direction:
      reverse: function() {
        return new Line2D(this.normal.negated(), -this.w);
      },
      equals: function(l) {
        return l.normal.equals(this.normal) && l.w === this.w;
      },
      origin: function() {
        return this.normal.times(this.w);
      },
      direction: function() {
        return this.normal.normal();
      },
      xAtY: function(y) {
        let x = (this.w - this.normal._y * y) / this.normal.x;
        return x;
      },
      absDistanceToPoint: function(point) {
        point = new Vector2D(point);
        let pointProjected = point.dot(this.normal);
        let distance = Math.abs(pointProjected - this.w);
        return distance;
      },
      /* FIXME: has error - origin is not defined, the method is never used
       closestPoint: function(point) {
           point = new Vector2D(point);
           let vector = point.dot(this.direction());
           return origin.plus(vector);
       },
       */
      // intersection between two lines, returns point as Vector2D
      intersectWithLine: function(line2d) {
        let point = solve2Linear(this.normal.x, this.normal.y, line2d.normal.x, line2d.normal.y, this.w, line2d.w);
        point = new Vector2D(point);
        return point;
      },
      transform: function(matrix4x4) {
        let origin = new Vector2D(0, 0);
        let pointOnPlane = this.normal.times(this.w);
        let neworigin = origin.multiply4x4(matrix4x4);
        let neworiginPlusNormal = this.normal.multiply4x4(matrix4x4);
        let newnormal = neworiginPlusNormal.minus(neworigin);
        let newpointOnPlane = pointOnPlane.multiply4x4(matrix4x4);
        let neww = newnormal.dot(newpointOnPlane);
        return new Line2D(newnormal, neww);
      }
    };
    module.exports = Line2D;
  }
});

// src/core/vendor/csg/src/core/constants.js
var require_constants = __commonJS({
  "src/core/vendor/csg/src/core/constants.js"(exports, module) {
    "use strict";
    var _CSGDEBUG = false;
    var defaultResolution2D = 32;
    var defaultResolution3D = 12;
    var EPS = 1e-5;
    var angleEPS = 0.1;
    var areaEPS = 0.5 * EPS * EPS * Math.sin(angleEPS);
    var all = 0;
    var top = 1;
    var bottom = 2;
    var left = 3;
    var right = 4;
    var front = 5;
    var back = 6;
    var staticTag = 1;
    var getTag = () => staticTag++;
    module.exports = {
      _CSGDEBUG,
      defaultResolution2D,
      defaultResolution3D,
      EPS,
      angleEPS,
      areaEPS,
      all,
      top,
      bottom,
      left,
      right,
      front,
      back,
      staticTag,
      getTag
    };
  }
});

// src/core/vendor/csg/src/core/math/Line3.js
var require_Line3 = __commonJS({
  "src/core/vendor/csg/src/core/math/Line3.js"(exports, module) {
    "use strict";
    var Vector3D = require_Vector3();
    var { EPS } = require_constants();
    var { solve2Linear } = require_utils();
    var Line3D = function(point, direction) {
      point = new Vector3D(point);
      direction = new Vector3D(direction);
      this.point = point;
      this.direction = direction.unit();
    };
    Line3D.fromPoints = function(p1, p2) {
      p1 = new Vector3D(p1);
      p2 = new Vector3D(p2);
      let direction = p2.minus(p1);
      return new Line3D(p1, direction);
    };
    Line3D.fromPlanes = function(p1, p2) {
      let direction = p1.normal.cross(p2.normal);
      let l = direction.length();
      if (l < EPS) {
        throw new Error("Parallel planes");
      }
      direction = direction.times(1 / l);
      let mabsx = Math.abs(direction.x);
      let mabsy = Math.abs(direction.y);
      let mabsz = Math.abs(direction.z);
      let origin;
      if (mabsx >= mabsy && mabsx >= mabsz) {
        let r = solve2Linear(p1.normal.y, p1.normal.z, p2.normal.y, p2.normal.z, p1.w, p2.w);
        origin = new Vector3D(0, r[0], r[1]);
      } else if (mabsy >= mabsx && mabsy >= mabsz) {
        let r = solve2Linear(p1.normal.x, p1.normal.z, p2.normal.x, p2.normal.z, p1.w, p2.w);
        origin = new Vector3D(r[0], 0, r[1]);
      } else {
        let r = solve2Linear(p1.normal.x, p1.normal.y, p2.normal.x, p2.normal.y, p1.w, p2.w);
        origin = new Vector3D(r[0], r[1], 0);
      }
      return new Line3D(origin, direction);
    };
    Line3D.prototype = {
      intersectWithPlane: function(plane) {
        let labda = (plane.w - plane.normal.dot(this.point)) / plane.normal.dot(this.direction);
        let point = this.point.plus(this.direction.times(labda));
        return point;
      },
      clone: function(line) {
        return new Line3D(this.point.clone(), this.direction.clone());
      },
      reverse: function() {
        return new Line3D(this.point.clone(), this.direction.negated());
      },
      transform: function(matrix4x4) {
        let newpoint = this.point.multiply4x4(matrix4x4);
        let pointPlusDirection = this.point.plus(this.direction);
        let newPointPlusDirection = pointPlusDirection.multiply4x4(matrix4x4);
        let newdirection = newPointPlusDirection.minus(newpoint);
        return new Line3D(newpoint, newdirection);
      },
      closestPointOnLine: function(point) {
        point = new Vector3D(point);
        let t = point.minus(this.point).dot(this.direction) / this.direction.dot(this.direction);
        let closestpoint = this.point.plus(this.direction.times(t));
        return closestpoint;
      },
      distanceToPoint: function(point) {
        point = new Vector3D(point);
        let closestpoint = this.closestPointOnLine(point);
        let distancevector = point.minus(closestpoint);
        let distance = distancevector.length();
        return distance;
      },
      equals: function(line3d) {
        if (!this.direction.equals(line3d.direction)) return false;
        let distance = this.distanceToPoint(line3d.point);
        if (distance > EPS) return false;
        return true;
      }
    };
    module.exports = Line3D;
  }
});

// src/core/vendor/csg/src/core/math/Plane.js
var require_Plane = __commonJS({
  "src/core/vendor/csg/src/core/math/Plane.js"(exports, module) {
    "use strict";
    var Vector3D = require_Vector3();
    var Line3D = require_Line3();
    var { EPS, getTag } = require_constants();
    var Plane = function(normal, w) {
      this.normal = normal;
      this.w = w;
    };
    Plane.fromObject = function(obj) {
      let normal = new Vector3D(obj.normal);
      let w = parseFloat(obj.w);
      return new Plane(normal, w);
    };
    Plane.fromVector3Ds = function(a, b, c) {
      let n = b.minus(a).cross(c.minus(a)).unit();
      return new Plane(n, n.dot(a));
    };
    Plane.anyPlaneFromVector3Ds = function(a, b, c) {
      let v1 = b.minus(a);
      let v2 = c.minus(a);
      if (v1.length() < EPS) {
        v1 = v2.randomNonParallelVector();
      }
      if (v2.length() < EPS) {
        v2 = v1.randomNonParallelVector();
      }
      let normal = v1.cross(v2);
      if (normal.length() < EPS) {
        v2 = v1.randomNonParallelVector();
        normal = v1.cross(v2);
      }
      normal = normal.unit();
      return new Plane(normal, normal.dot(a));
    };
    Plane.fromPoints = function(a, b, c) {
      a = new Vector3D(a);
      b = new Vector3D(b);
      c = new Vector3D(c);
      return Plane.fromVector3Ds(a, b, c);
    };
    Plane.fromNormalAndPoint = function(normal, point) {
      normal = new Vector3D(normal);
      point = new Vector3D(point);
      normal = normal.unit();
      let w = point.dot(normal);
      return new Plane(normal, w);
    };
    Plane.prototype = {
      flipped: function() {
        return new Plane(this.normal.negated(), -this.w);
      },
      getTag: function() {
        let result = this.tag;
        if (!result) {
          result = getTag();
          this.tag = result;
        }
        return result;
      },
      equals: function(n) {
        return this.normal.equals(n.normal) && this.w === n.w;
      },
      transform: function(matrix4x4) {
        let ismirror = matrix4x4.isMirroring();
        let r = this.normal.randomNonParallelVector();
        let u = this.normal.cross(r);
        let v = this.normal.cross(u);
        let point1 = this.normal.times(this.w);
        let point2 = point1.plus(u);
        let point3 = point1.plus(v);
        point1 = point1.multiply4x4(matrix4x4);
        point2 = point2.multiply4x4(matrix4x4);
        point3 = point3.multiply4x4(matrix4x4);
        let newplane = Plane.fromVector3Ds(point1, point2, point3);
        if (ismirror) {
          newplane = newplane.flipped();
        }
        return newplane;
      },
      // robust splitting of a line by a plane
      // will work even if the line is parallel to the plane
      splitLineBetweenPoints: function(p1, p2) {
        let direction = p2.minus(p1);
        let labda = (this.w - this.normal.dot(p1)) / this.normal.dot(direction);
        if (isNaN(labda)) labda = 0;
        if (labda > 1) labda = 1;
        if (labda < 0) labda = 0;
        let result = p1.plus(direction.times(labda));
        return result;
      },
      // returns Vector3D
      intersectWithLine: function(line3d) {
        return line3d.intersectWithPlane(this);
      },
      // intersection of two planes
      intersectWithPlane: function(plane) {
        return Line3D.fromPlanes(this, plane);
      },
      signedDistanceToPoint: function(point) {
        let t = this.normal.dot(point) - this.w;
        return t;
      },
      toString: function() {
        return "[normal: " + this.normal.toString() + ", w: " + this.w + "]";
      },
      mirrorPoint: function(point3d) {
        let distance = this.signedDistanceToPoint(point3d);
        let mirrored = point3d.minus(this.normal.times(distance * 2));
        return mirrored;
      }
    };
    module.exports = Plane;
  }
});

// src/core/vendor/csg/src/core/math/OrthoNormalBasis.js
var require_OrthoNormalBasis = __commonJS({
  "src/core/vendor/csg/src/core/math/OrthoNormalBasis.js"(exports, module) {
    "use strict";
    var Vector2D = require_Vector2();
    var Vector3D = require_Vector3();
    var Line2D = require_Line2();
    var Line3D = require_Line3();
    var Plane = require_Plane();
    var OrthoNormalBasis = function(plane, rightvector) {
      if (arguments.length < 2) {
        rightvector = plane.normal.randomNonParallelVector();
      } else {
        rightvector = new Vector3D(rightvector);
      }
      this.v = plane.normal.cross(rightvector).unit();
      this.u = this.v.cross(plane.normal);
      this.plane = plane;
      this.planeorigin = plane.normal.times(plane.w);
    };
    OrthoNormalBasis.GetCartesian = function(xaxisid, yaxisid) {
      let axisid = xaxisid + "/" + yaxisid;
      let planenormal, rightvector;
      if (axisid === "X/Y") {
        planenormal = [0, 0, 1];
        rightvector = [1, 0, 0];
      } else if (axisid === "Y/-X") {
        planenormal = [0, 0, 1];
        rightvector = [0, 1, 0];
      } else if (axisid === "-X/-Y") {
        planenormal = [0, 0, 1];
        rightvector = [-1, 0, 0];
      } else if (axisid === "-Y/X") {
        planenormal = [0, 0, 1];
        rightvector = [0, -1, 0];
      } else if (axisid === "-X/Y") {
        planenormal = [0, 0, -1];
        rightvector = [-1, 0, 0];
      } else if (axisid === "-Y/-X") {
        planenormal = [0, 0, -1];
        rightvector = [0, -1, 0];
      } else if (axisid === "X/-Y") {
        planenormal = [0, 0, -1];
        rightvector = [1, 0, 0];
      } else if (axisid === "Y/X") {
        planenormal = [0, 0, -1];
        rightvector = [0, 1, 0];
      } else if (axisid === "X/Z") {
        planenormal = [0, -1, 0];
        rightvector = [1, 0, 0];
      } else if (axisid === "Z/-X") {
        planenormal = [0, -1, 0];
        rightvector = [0, 0, 1];
      } else if (axisid === "-X/-Z") {
        planenormal = [0, -1, 0];
        rightvector = [-1, 0, 0];
      } else if (axisid === "-Z/X") {
        planenormal = [0, -1, 0];
        rightvector = [0, 0, -1];
      } else if (axisid === "-X/Z") {
        planenormal = [0, 1, 0];
        rightvector = [-1, 0, 0];
      } else if (axisid === "-Z/-X") {
        planenormal = [0, 1, 0];
        rightvector = [0, 0, -1];
      } else if (axisid === "X/-Z") {
        planenormal = [0, 1, 0];
        rightvector = [1, 0, 0];
      } else if (axisid === "Z/X") {
        planenormal = [0, 1, 0];
        rightvector = [0, 0, 1];
      } else if (axisid === "Y/Z") {
        planenormal = [1, 0, 0];
        rightvector = [0, 1, 0];
      } else if (axisid === "Z/-Y") {
        planenormal = [1, 0, 0];
        rightvector = [0, 0, 1];
      } else if (axisid === "-Y/-Z") {
        planenormal = [1, 0, 0];
        rightvector = [0, -1, 0];
      } else if (axisid === "-Z/Y") {
        planenormal = [1, 0, 0];
        rightvector = [0, 0, -1];
      } else if (axisid === "-Y/Z") {
        planenormal = [-1, 0, 0];
        rightvector = [0, -1, 0];
      } else if (axisid === "-Z/-Y") {
        planenormal = [-1, 0, 0];
        rightvector = [0, 0, -1];
      } else if (axisid === "Y/-Z") {
        planenormal = [-1, 0, 0];
        rightvector = [0, 1, 0];
      } else if (axisid === "Z/Y") {
        planenormal = [-1, 0, 0];
        rightvector = [0, 0, 1];
      } else {
        throw new Error("OrthoNormalBasis.GetCartesian: invalid combination of axis identifiers. Should pass two string arguments from [X,Y,Z,-X,-Y,-Z], being two different axes.");
      }
      return new OrthoNormalBasis(new Plane(new Vector3D(planenormal), 0), new Vector3D(rightvector));
    };
    OrthoNormalBasis.Z0Plane = function() {
      let plane = new Plane(new Vector3D([0, 0, 1]), 0);
      return new OrthoNormalBasis(plane, new Vector3D([1, 0, 0]));
    };
    OrthoNormalBasis.prototype = {
      getProjectionMatrix: function() {
        const Matrix4x4 = require_Matrix4();
        return new Matrix4x4([
          this.u.x,
          this.v.x,
          this.plane.normal.x,
          0,
          this.u.y,
          this.v.y,
          this.plane.normal.y,
          0,
          this.u.z,
          this.v.z,
          this.plane.normal.z,
          0,
          0,
          0,
          -this.plane.w,
          1
        ]);
      },
      getInverseProjectionMatrix: function() {
        const Matrix4x4 = require_Matrix4();
        let p = this.plane.normal.times(this.plane.w);
        return new Matrix4x4([
          this.u.x,
          this.u.y,
          this.u.z,
          0,
          this.v.x,
          this.v.y,
          this.v.z,
          0,
          this.plane.normal.x,
          this.plane.normal.y,
          this.plane.normal.z,
          0,
          p.x,
          p.y,
          p.z,
          1
        ]);
      },
      to2D: function(vec3) {
        return new Vector2D(vec3.dot(this.u), vec3.dot(this.v));
      },
      to3D: function(vec2) {
        return this.planeorigin.plus(this.u.times(vec2.x)).plus(this.v.times(vec2.y));
      },
      line3Dto2D: function(line3d) {
        let a = line3d.point;
        let b = line3d.direction.plus(a);
        let a2d = this.to2D(a);
        let b2d = this.to2D(b);
        return Line2D.fromPoints(a2d, b2d);
      },
      line2Dto3D: function(line2d) {
        let a = line2d.origin();
        let b = line2d.direction().plus(a);
        let a3d = this.to3D(a);
        let b3d = this.to3D(b);
        return Line3D.fromPoints(a3d, b3d);
      },
      transform: function(matrix4x4) {
        let newplane = this.plane.transform(matrix4x4);
        let rightpointTransformed = this.u.transform(matrix4x4);
        let originTransformed = new Vector3D(0, 0, 0).transform(matrix4x4);
        let newrighthandvector = rightpointTransformed.minus(originTransformed);
        let newbasis = new OrthoNormalBasis(newplane, newrighthandvector);
        return newbasis;
      }
    };
    module.exports = OrthoNormalBasis;
  }
});

// src/core/vendor/csg/src/core/math/Matrix4.js
var require_Matrix4 = __commonJS({
  "src/core/vendor/csg/src/core/math/Matrix4.js"(exports, module) {
    "use strict";
    var Vector3D = require_Vector3();
    var Vector2D = require_Vector2();
    var OrthoNormalBasis = require_OrthoNormalBasis();
    var Plane = require_Plane();
    var Matrix4x4 = function(elements) {
      if (arguments.length >= 1) {
        this.elements = elements;
      } else {
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      }
    };
    Matrix4x4.prototype = {
      plus: function(m) {
        var r = [];
        for (var i = 0; i < 16; i++) {
          r[i] = this.elements[i] + m.elements[i];
        }
        return new Matrix4x4(r);
      },
      minus: function(m) {
        var r = [];
        for (var i = 0; i < 16; i++) {
          r[i] = this.elements[i] - m.elements[i];
        }
        return new Matrix4x4(r);
      },
      // right multiply by another 4x4 matrix:
      multiply: function(m) {
        var this0 = this.elements[0];
        var this1 = this.elements[1];
        var this2 = this.elements[2];
        var this3 = this.elements[3];
        var this4 = this.elements[4];
        var this5 = this.elements[5];
        var this6 = this.elements[6];
        var this7 = this.elements[7];
        var this8 = this.elements[8];
        var this9 = this.elements[9];
        var this10 = this.elements[10];
        var this11 = this.elements[11];
        var this12 = this.elements[12];
        var this13 = this.elements[13];
        var this14 = this.elements[14];
        var this15 = this.elements[15];
        var m0 = m.elements[0];
        var m1 = m.elements[1];
        var m2 = m.elements[2];
        var m3 = m.elements[3];
        var m4 = m.elements[4];
        var m5 = m.elements[5];
        var m6 = m.elements[6];
        var m7 = m.elements[7];
        var m8 = m.elements[8];
        var m9 = m.elements[9];
        var m10 = m.elements[10];
        var m11 = m.elements[11];
        var m12 = m.elements[12];
        var m13 = m.elements[13];
        var m14 = m.elements[14];
        var m15 = m.elements[15];
        var result = [];
        result[0] = this0 * m0 + this1 * m4 + this2 * m8 + this3 * m12;
        result[1] = this0 * m1 + this1 * m5 + this2 * m9 + this3 * m13;
        result[2] = this0 * m2 + this1 * m6 + this2 * m10 + this3 * m14;
        result[3] = this0 * m3 + this1 * m7 + this2 * m11 + this3 * m15;
        result[4] = this4 * m0 + this5 * m4 + this6 * m8 + this7 * m12;
        result[5] = this4 * m1 + this5 * m5 + this6 * m9 + this7 * m13;
        result[6] = this4 * m2 + this5 * m6 + this6 * m10 + this7 * m14;
        result[7] = this4 * m3 + this5 * m7 + this6 * m11 + this7 * m15;
        result[8] = this8 * m0 + this9 * m4 + this10 * m8 + this11 * m12;
        result[9] = this8 * m1 + this9 * m5 + this10 * m9 + this11 * m13;
        result[10] = this8 * m2 + this9 * m6 + this10 * m10 + this11 * m14;
        result[11] = this8 * m3 + this9 * m7 + this10 * m11 + this11 * m15;
        result[12] = this12 * m0 + this13 * m4 + this14 * m8 + this15 * m12;
        result[13] = this12 * m1 + this13 * m5 + this14 * m9 + this15 * m13;
        result[14] = this12 * m2 + this13 * m6 + this14 * m10 + this15 * m14;
        result[15] = this12 * m3 + this13 * m7 + this14 * m11 + this15 * m15;
        return new Matrix4x4(result);
      },
      clone: function() {
        var elements = this.elements.map(function(p) {
          return p;
        });
        return new Matrix4x4(elements);
      },
      // Right multiply the matrix by a Vector3D (interpreted as 3 row, 1 column)
      // (result = M*v)
      // Fourth element is taken as 1
      rightMultiply1x3Vector: function(v) {
        var v0 = v._x;
        var v1 = v._y;
        var v2 = v._z;
        var v3 = 1;
        var x = v0 * this.elements[0] + v1 * this.elements[1] + v2 * this.elements[2] + v3 * this.elements[3];
        var y = v0 * this.elements[4] + v1 * this.elements[5] + v2 * this.elements[6] + v3 * this.elements[7];
        var z = v0 * this.elements[8] + v1 * this.elements[9] + v2 * this.elements[10] + v3 * this.elements[11];
        var w = v0 * this.elements[12] + v1 * this.elements[13] + v2 * this.elements[14] + v3 * this.elements[15];
        if (w !== 1) {
          var invw = 1 / w;
          x *= invw;
          y *= invw;
          z *= invw;
        }
        return new Vector3D(x, y, z);
      },
      // Multiply a Vector3D (interpreted as 3 column, 1 row) by this matrix
      // (result = v*M)
      // Fourth element is taken as 1
      leftMultiply1x3Vector: function(v) {
        var v0 = v._x;
        var v1 = v._y;
        var v2 = v._z;
        var v3 = 1;
        var x = v0 * this.elements[0] + v1 * this.elements[4] + v2 * this.elements[8] + v3 * this.elements[12];
        var y = v0 * this.elements[1] + v1 * this.elements[5] + v2 * this.elements[9] + v3 * this.elements[13];
        var z = v0 * this.elements[2] + v1 * this.elements[6] + v2 * this.elements[10] + v3 * this.elements[14];
        var w = v0 * this.elements[3] + v1 * this.elements[7] + v2 * this.elements[11] + v3 * this.elements[15];
        if (w !== 1) {
          var invw = 1 / w;
          x *= invw;
          y *= invw;
          z *= invw;
        }
        return new Vector3D(x, y, z);
      },
      // Right multiply the matrix by a Vector2D (interpreted as 2 row, 1 column)
      // (result = M*v)
      // Fourth element is taken as 1
      rightMultiply1x2Vector: function(v) {
        var v0 = v.x;
        var v1 = v.y;
        var v2 = 0;
        var v3 = 1;
        var x = v0 * this.elements[0] + v1 * this.elements[1] + v2 * this.elements[2] + v3 * this.elements[3];
        var y = v0 * this.elements[4] + v1 * this.elements[5] + v2 * this.elements[6] + v3 * this.elements[7];
        var z = v0 * this.elements[8] + v1 * this.elements[9] + v2 * this.elements[10] + v3 * this.elements[11];
        var w = v0 * this.elements[12] + v1 * this.elements[13] + v2 * this.elements[14] + v3 * this.elements[15];
        if (w !== 1) {
          var invw = 1 / w;
          x *= invw;
          y *= invw;
          z *= invw;
        }
        return new Vector2D(x, y);
      },
      // Multiply a Vector2D (interpreted as 2 column, 1 row) by this matrix
      // (result = v*M)
      // Fourth element is taken as 1
      leftMultiply1x2Vector: function(v) {
        var v0 = v.x;
        var v1 = v.y;
        var v2 = 0;
        var v3 = 1;
        var x = v0 * this.elements[0] + v1 * this.elements[4] + v2 * this.elements[8] + v3 * this.elements[12];
        var y = v0 * this.elements[1] + v1 * this.elements[5] + v2 * this.elements[9] + v3 * this.elements[13];
        var z = v0 * this.elements[2] + v1 * this.elements[6] + v2 * this.elements[10] + v3 * this.elements[14];
        var w = v0 * this.elements[3] + v1 * this.elements[7] + v2 * this.elements[11] + v3 * this.elements[15];
        if (w !== 1) {
          var invw = 1 / w;
          x *= invw;
          y *= invw;
          z *= invw;
        }
        return new Vector2D(x, y);
      },
      // determine whether this matrix is a mirroring transformation
      isMirroring: function() {
        var u = new Vector3D(this.elements[0], this.elements[4], this.elements[8]);
        var v = new Vector3D(this.elements[1], this.elements[5], this.elements[9]);
        var w = new Vector3D(this.elements[2], this.elements[6], this.elements[10]);
        var mirrorvalue = u.cross(v).dot(w);
        var ismirror = mirrorvalue < 0;
        return ismirror;
      }
    };
    Matrix4x4.unity = function() {
      return new Matrix4x4();
    };
    Matrix4x4.rotationX = function(degrees) {
      var radians = degrees * Math.PI * (1 / 180);
      var cos = Math.cos(radians);
      var sin = Math.sin(radians);
      var els = [
        1,
        0,
        0,
        0,
        0,
        cos,
        sin,
        0,
        0,
        -sin,
        cos,
        0,
        0,
        0,
        0,
        1
      ];
      return new Matrix4x4(els);
    };
    Matrix4x4.rotationY = function(degrees) {
      var radians = degrees * Math.PI * (1 / 180);
      var cos = Math.cos(radians);
      var sin = Math.sin(radians);
      var els = [
        cos,
        0,
        -sin,
        0,
        0,
        1,
        0,
        0,
        sin,
        0,
        cos,
        0,
        0,
        0,
        0,
        1
      ];
      return new Matrix4x4(els);
    };
    Matrix4x4.rotationZ = function(degrees) {
      var radians = degrees * Math.PI * (1 / 180);
      var cos = Math.cos(radians);
      var sin = Math.sin(radians);
      var els = [
        cos,
        sin,
        0,
        0,
        -sin,
        cos,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ];
      return new Matrix4x4(els);
    };
    Matrix4x4.rotation = function(rotationCenter, rotationAxis, degrees) {
      rotationCenter = new Vector3D(rotationCenter);
      rotationAxis = new Vector3D(rotationAxis);
      var rotationPlane = Plane.fromNormalAndPoint(rotationAxis, rotationCenter);
      var orthobasis = new OrthoNormalBasis(rotationPlane);
      var transformation = Matrix4x4.translation(rotationCenter.negated());
      transformation = transformation.multiply(orthobasis.getProjectionMatrix());
      transformation = transformation.multiply(Matrix4x4.rotationZ(degrees));
      transformation = transformation.multiply(orthobasis.getInverseProjectionMatrix());
      transformation = transformation.multiply(Matrix4x4.translation(rotationCenter));
      return transformation;
    };
    Matrix4x4.translation = function(v) {
      var vec = new Vector3D(v);
      var els = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, vec.x, vec.y, vec.z, 1];
      return new Matrix4x4(els);
    };
    Matrix4x4.mirroring = function(plane) {
      var nx = plane.normal.x;
      var ny = plane.normal.y;
      var nz = plane.normal.z;
      var w = plane.w;
      var els = [
        1 - 2 * nx * nx,
        -2 * ny * nx,
        -2 * nz * nx,
        0,
        -2 * nx * ny,
        1 - 2 * ny * ny,
        -2 * nz * ny,
        0,
        -2 * nx * nz,
        -2 * ny * nz,
        1 - 2 * nz * nz,
        0,
        2 * nx * w,
        2 * ny * w,
        2 * nz * w,
        1
      ];
      return new Matrix4x4(els);
    };
    Matrix4x4.scaling = function(v) {
      var vec = new Vector3D(v);
      var els = [
        vec.x,
        0,
        0,
        0,
        0,
        vec.y,
        0,
        0,
        0,
        0,
        vec.z,
        0,
        0,
        0,
        0,
        1
      ];
      return new Matrix4x4(els);
    };
    module.exports = Matrix4x4;
  }
});

// src/core/vendor/csg/src/core/mutators.js
var require_mutators = __commonJS({
  "src/core/vendor/csg/src/core/mutators.js"(exports, module) {
    "use strict";
    var Matrix4x4 = require_Matrix4();
    var Vector3D = require_Vector3();
    var Plane = require_Plane();
    var addTransformationMethodsToPrototype = function(prot) {
      prot.mirrored = function(plane) {
        return this.transform(Matrix4x4.mirroring(plane));
      };
      prot.mirroredX = function() {
        let plane = new Plane(Vector3D.Create(1, 0, 0), 0);
        return this.mirrored(plane);
      };
      prot.mirroredY = function() {
        let plane = new Plane(Vector3D.Create(0, 1, 0), 0);
        return this.mirrored(plane);
      };
      prot.mirroredZ = function() {
        let plane = new Plane(Vector3D.Create(0, 0, 1), 0);
        return this.mirrored(plane);
      };
      prot.translate = function(v) {
        return this.transform(Matrix4x4.translation(v));
      };
      prot.scale = function(f) {
        return this.transform(Matrix4x4.scaling(f));
      };
      prot.rotateX = function(deg) {
        return this.transform(Matrix4x4.rotationX(deg));
      };
      prot.rotateY = function(deg) {
        return this.transform(Matrix4x4.rotationY(deg));
      };
      prot.rotateZ = function(deg) {
        return this.transform(Matrix4x4.rotationZ(deg));
      };
      prot.rotate = function(rotationCenter, rotationAxis, degrees) {
        return this.transform(Matrix4x4.rotation(rotationCenter, rotationAxis, degrees));
      };
      prot.rotateEulerAngles = function(alpha, beta, gamma, position) {
        position = position || [0, 0, 0];
        let Rz1 = Matrix4x4.rotationZ(alpha);
        let Rx = Matrix4x4.rotationX(beta);
        let Rz2 = Matrix4x4.rotationZ(gamma);
        let T = Matrix4x4.translation(new Vector3D(position));
        return this.transform(Rz2.multiply(Rx).multiply(Rz1).multiply(T));
      };
    };
    var addCenteringToPrototype = function(prot, axes) {
      prot.center = function(cAxes) {
        cAxes = Array.prototype.map.call(arguments, function(a) {
          return a;
        });
        if (!cAxes.length) {
          cAxes = axes.slice();
        }
        let b = this.getBounds();
        return this.translate(axes.map(function(a) {
          return cAxes.indexOf(a) > -1 ? -(b[0][a] + b[1][a]) / 2 : 0;
        }));
      };
    };
    module.exports = {
      addTransformationMethodsToPrototype,
      addCenteringToPrototype
    };
  }
});

// src/core/vendor/csg/src/core/math/Vertex3.js
var require_Vertex3 = __commonJS({
  "src/core/vendor/csg/src/core/math/Vertex3.js"(exports, module) {
    "use strict";
    var Vector3D = require_Vector3();
    var { getTag } = require_constants();
    var Vertex = function(pos) {
      this.pos = pos;
    };
    Vertex.fromObject = function(obj) {
      var pos = new Vector3D(obj.pos);
      return new Vertex(pos);
    };
    Vertex.prototype = {
      // Return a vertex with all orientation-specific data (e.g. vertex normal) flipped. Called when the
      // orientation of a polygon is flipped.
      flipped: function() {
        return this;
      },
      getTag: function() {
        var result = this.tag;
        if (!result) {
          result = getTag();
          this.tag = result;
        }
        return result;
      },
      // Create a new vertex between this vertex and `other` by linearly
      // interpolating all properties using a parameter of `t`. Subclasses should
      // override this to interpolate additional properties.
      interpolate: function(other, t) {
        var newpos = this.pos.lerp(other.pos, t);
        return new Vertex(newpos);
      },
      // Affine transformation of vertex. Returns a new Vertex
      transform: function(matrix4x4) {
        var newpos = this.pos.multiply4x4(matrix4x4);
        return new Vertex(newpos);
      },
      toString: function() {
        return this.pos.toString();
      }
    };
    module.exports = Vertex;
  }
});

// src/core/vendor/csg/src/core/connectors.js
var require_connectors = __commonJS({
  "src/core/vendor/csg/src/core/connectors.js"(exports, module) {
    "use strict";
    var Vector3D = require_Vector3();
    var Line3D = require_Line3();
    var Matrix4x4 = require_Matrix4();
    var OrthoNormalBasis = require_OrthoNormalBasis();
    var Plane = require_Plane();
    var Connector = function(point, axisvector, normalvector) {
      this.point = new Vector3D(point);
      this.axisvector = new Vector3D(axisvector).unit();
      this.normalvector = new Vector3D(normalvector).unit();
    };
    Connector.prototype = {
      normalized: function() {
        let axisvector = this.axisvector.unit();
        let n = this.normalvector.cross(axisvector).unit();
        let normalvector = axisvector.cross(n);
        return new Connector(this.point, axisvector, normalvector);
      },
      transform: function(matrix4x4) {
        let point = this.point.multiply4x4(matrix4x4);
        let axisvector = this.point.plus(this.axisvector).multiply4x4(matrix4x4).minus(point);
        let normalvector = this.point.plus(this.normalvector).multiply4x4(matrix4x4).minus(point);
        return new Connector(point, axisvector, normalvector);
      },
      // Get the transformation matrix to connect this Connector to another connector
      //   other: a Connector to which this connector should be connected
      //   mirror: false: the 'axis' vectors of the connectors should point in the same direction
      //           true: the 'axis' vectors of the connectors should point in opposite direction
      //   normalrotation: degrees of rotation between the 'normal' vectors of the two
      //                   connectors
      getTransformationTo: function(other, mirror, normalrotation) {
        mirror = mirror ? true : false;
        normalrotation = normalrotation ? Number(normalrotation) : 0;
        let us = this.normalized();
        other = other.normalized();
        let transformation = Matrix4x4.translation(this.point.negated());
        let axesplane = Plane.anyPlaneFromVector3Ds(
          new Vector3D(0, 0, 0),
          us.axisvector,
          other.axisvector
        );
        let axesbasis = new OrthoNormalBasis(axesplane);
        let angle1 = axesbasis.to2D(us.axisvector).angle();
        let angle2 = axesbasis.to2D(other.axisvector).angle();
        let rotation = 180 * (angle2 - angle1) / Math.PI;
        if (mirror) rotation += 180;
        transformation = transformation.multiply(axesbasis.getProjectionMatrix());
        transformation = transformation.multiply(Matrix4x4.rotationZ(rotation));
        transformation = transformation.multiply(axesbasis.getInverseProjectionMatrix());
        let usAxesAligned = us.transform(transformation);
        let normalsplane = Plane.fromNormalAndPoint(other.axisvector, new Vector3D(0, 0, 0));
        let normalsbasis = new OrthoNormalBasis(normalsplane);
        angle1 = normalsbasis.to2D(usAxesAligned.normalvector).angle();
        angle2 = normalsbasis.to2D(other.normalvector).angle();
        rotation = 180 * (angle2 - angle1) / Math.PI;
        rotation += normalrotation;
        transformation = transformation.multiply(normalsbasis.getProjectionMatrix());
        transformation = transformation.multiply(Matrix4x4.rotationZ(rotation));
        transformation = transformation.multiply(normalsbasis.getInverseProjectionMatrix());
        transformation = transformation.multiply(Matrix4x4.translation(other.point));
        return transformation;
      },
      axisLine: function() {
        return new Line3D(this.point, this.axisvector);
      },
      // creates a new Connector, with the connection point moved in the direction of the axisvector
      extend: function(distance) {
        let newpoint = this.point.plus(this.axisvector.unit().times(distance));
        return new Connector(newpoint, this.axisvector, this.normalvector);
      }
    };
    var ConnectorList = function(connectors) {
      this.connectors_ = connectors ? connectors.slice() : [];
    };
    ConnectorList.defaultNormal = [0, 0, 1];
    ConnectorList.fromPath2D = function(path2D, arg1, arg2) {
      if (arguments.length === 3) {
        return ConnectorList._fromPath2DTangents(path2D, arg1, arg2);
      } else if (arguments.length === 2) {
        return ConnectorList._fromPath2DExplicit(path2D, arg1);
      } else {
        throw new Error("call with path2D and either 2 direction vectors, or a function returning direction vectors");
      }
    };
    ConnectorList._fromPath2DTangents = function(path2D, start, end) {
      let axis;
      let pathLen = path2D.points.length;
      let result = new ConnectorList([new Connector(
        path2D.points[0],
        start,
        ConnectorList.defaultNormal
      )]);
      path2D.points.slice(1, pathLen - 1).forEach(function(p2, i) {
        axis = path2D.points[i + 2].minus(path2D.points[i]).toVector3D(0);
        result.appendConnector(new Connector(
          p2.toVector3D(0),
          axis,
          ConnectorList.defaultNormal
        ));
      }, this);
      result.appendConnector(new Connector(
        path2D.points[pathLen - 1],
        end,
        ConnectorList.defaultNormal
      ));
      result.closed = path2D.closed;
      return result;
    };
    ConnectorList._fromPath2DExplicit = function(path2D, angleIsh) {
      function getAngle(angleIsh2, pt, i) {
        if (typeof angleIsh2 === "function") {
          angleIsh2 = angleIsh2(pt, i);
        }
        return angleIsh2;
      }
      let result = new ConnectorList(
        path2D.points.map(function(p2, i) {
          return new Connector(
            p2.toVector3D(0),
            Vector3D.Create(1, 0, 0).rotateZ(getAngle(angleIsh, p2, i)),
            ConnectorList.defaultNormal
          );
        }, this)
      );
      result.closed = path2D.closed;
      return result;
    };
    ConnectorList.prototype = {
      setClosed: function(closed) {
        this.closed = !!closed;
      },
      appendConnector: function(conn) {
        this.connectors_.push(conn);
      },
      /*
       * arguments: cagish: a cag or a function(connector) returning a cag
       *            closed: whether the 3d path defined by connectors location
       *              should be closed or stay open
       *              Note: don't duplicate connectors in the path
       * TODO: consider an option "maySelfIntersect" to close & force union all single segments
       */
      followWith: function(cagish) {
        const CSG = require_CSG();
        this.verify();
        function getCag(cagish2, connector) {
          if (typeof cagish2 === "function") {
            cagish2 = cagish2(connector.point, connector.axisvector, connector.normalvector);
          }
          return cagish2;
        }
        let polygons = [];
        let currCag;
        let prevConnector = this.connectors_[this.connectors_.length - 1];
        let prevCag = getCag(cagish, prevConnector);
        this.connectors_.forEach(function(connector, notFirst) {
          currCag = getCag(cagish, connector);
          if (notFirst || this.closed) {
            polygons.push.apply(polygons, prevCag._toWallPolygons({
              toConnector1: prevConnector,
              toConnector2: connector,
              cag: currCag
            }));
          } else {
            polygons.push.apply(
              polygons,
              currCag._toPlanePolygons({ toConnector: connector, flipped: true })
            );
          }
          if (notFirst === this.connectors_.length - 1 && !this.closed) {
            polygons.push.apply(
              polygons,
              currCag._toPlanePolygons({ toConnector: connector })
            );
          }
          prevCag = currCag;
          prevConnector = connector;
        }, this);
        return CSG.fromPolygons(polygons).reTesselated().canonicalized();
      },
      /*
       * general idea behind these checks: connectors need to have smooth transition from one to another
       * TODO: add a check that 2 follow-on CAGs are not intersecting
       */
      verify: function() {
        let connI;
        let connI1;
        for (let i = 0; i < this.connectors_.length - 1; i++) {
          connI = this.connectors_[i];
          connI1 = this.connectors_[i + 1];
          if (connI1.point.minus(connI.point).dot(connI.axisvector) <= 0) {
            throw new Error("Invalid ConnectorList. Each connectors position needs to be within a <90deg range of previous connectors axisvector");
          }
          if (connI.axisvector.dot(connI1.axisvector) <= 0) {
            throw new Error("invalid ConnectorList. No neighboring connectors axisvectors may span a >=90deg angle");
          }
        }
      }
    };
    module.exports = { Connector, ConnectorList };
  }
});

// src/core/vendor/csg/src/core/math/Vertex2.js
var require_Vertex2 = __commonJS({
  "src/core/vendor/csg/src/core/math/Vertex2.js"(exports, module) {
    "use strict";
    var Vector2D = require_Vector2();
    var { getTag } = require_constants();
    var Vertex = function(pos) {
      this.pos = pos;
    };
    Vertex.fromObject = function(obj) {
      return new Vertex(new Vector2D(obj.pos._x, obj.pos._y));
    };
    Vertex.prototype = {
      toString: function() {
        return "(" + this.pos.x.toFixed(5) + "," + this.pos.y.toFixed(5) + ")";
      },
      getTag: function() {
        var result = this.tag;
        if (!result) {
          result = getTag();
          this.tag = result;
        }
        return result;
      }
    };
    module.exports = Vertex;
  }
});

// src/core/vendor/csg/src/core/math/Side.js
var require_Side = __commonJS({
  "src/core/vendor/csg/src/core/math/Side.js"(exports, module) {
    "use strict";
    var Vector2D = require_Vector2();
    var Vertex = require_Vertex2();
    var Vertex3 = require_Vertex3();
    var Polygon = require_Polygon3();
    var { getTag } = require_constants();
    var Side = function(vertex0, vertex1) {
      if (!(vertex0 instanceof Vertex)) throw new Error("Assertion failed");
      if (!(vertex1 instanceof Vertex)) throw new Error("Assertion failed");
      this.vertex0 = vertex0;
      this.vertex1 = vertex1;
    };
    Side.fromObject = function(obj) {
      var vertex0 = Vertex.fromObject(obj.vertex0);
      var vertex1 = Vertex.fromObject(obj.vertex1);
      return new Side(vertex0, vertex1);
    };
    Side._fromFakePolygon = function(polygon) {
      if (polygon.vertices.length < 4) {
        return null;
      }
      var vert1Indices = [];
      var pts2d = polygon.vertices.filter(function(v, i) {
        if (v.pos.z > 0) {
          vert1Indices.push(i);
          return true;
        }
        return false;
      }).map(function(v) {
        return new Vector2D(v.pos.x, v.pos.y);
      });
      if (pts2d.length !== 2) {
        throw new Error("Assertion failed: _fromFakePolygon: not enough points found");
      }
      var d = vert1Indices[1] - vert1Indices[0];
      if (d === 1 || d === 3) {
        if (d === 1) {
          pts2d.reverse();
        }
      } else {
        throw new Error("Assertion failed: _fromFakePolygon: unknown index ordering");
      }
      var result = new Side(new Vertex(pts2d[0]), new Vertex(pts2d[1]));
      return result;
    };
    Side.prototype = {
      toString: function() {
        return this.vertex0 + " -> " + this.vertex1;
      },
      toPolygon3D: function(z0, z1) {
        const vertices = [
          new Vertex3(this.vertex0.pos.toVector3D(z0)),
          new Vertex3(this.vertex1.pos.toVector3D(z0)),
          new Vertex3(this.vertex1.pos.toVector3D(z1)),
          new Vertex3(this.vertex0.pos.toVector3D(z1))
        ];
        return new Polygon(vertices);
      },
      transform: function(matrix4x4) {
        var newp1 = this.vertex0.pos.transform(matrix4x4);
        var newp2 = this.vertex1.pos.transform(matrix4x4);
        return new Side(new Vertex(newp1), new Vertex(newp2));
      },
      flipped: function() {
        return new Side(this.vertex1, this.vertex0);
      },
      direction: function() {
        return this.vertex1.pos.minus(this.vertex0.pos);
      },
      getTag: function() {
        var result = this.tag;
        if (!result) {
          result = getTag();
          this.tag = result;
        }
        return result;
      },
      lengthSquared: function() {
        let x = this.vertex1.pos.x - this.vertex0.pos.x;
        let y = this.vertex1.pos.y - this.vertex0.pos.y;
        return x * x + y * y;
      },
      length: function() {
        return Math.sqrt(this.lengthSquared());
      }
    };
    module.exports = Side;
  }
});

// src/core/vendor/csg/src/core/math/lineUtils.js
var require_lineUtils = __commonJS({
  "src/core/vendor/csg/src/core/math/lineUtils.js"(exports, module) {
    "use strict";
    var { EPS } = require_constants();
    var { solve2Linear } = require_utils();
    var linesIntersect = function(p0start, p0end, p1start, p1end) {
      if (p0end.equals(p1start) || p1end.equals(p0start)) {
        let d = p1end.minus(p1start).unit().plus(p0end.minus(p0start).unit()).length();
        if (d < EPS) {
          return true;
        }
      } else {
        let d0 = p0end.minus(p0start);
        let d1 = p1end.minus(p1start);
        if (Math.abs(d0.cross(d1)) < 1e-9) return false;
        let alphas = solve2Linear(-d0.x, d1.x, -d0.y, d1.y, p0start.x - p1start.x, p0start.y - p1start.y);
        if (alphas[0] > 1e-6 && alphas[0] < 0.999999 && alphas[1] > 1e-5 && alphas[1] < 0.999999) return true;
      }
      return false;
    };
    module.exports = { linesIntersect };
  }
});

// src/core/vendor/csg/src/core/utils/cagValidation.js
var require_cagValidation = __commonJS({
  "src/core/vendor/csg/src/core/utils/cagValidation.js"(exports, module) {
    "use strict";
    var { areaEPS } = require_constants();
    var { linesIntersect } = require_lineUtils();
    var isCAGValid = function(CAG) {
      let errors = [];
      if (CAG.isSelfIntersecting(true)) {
        errors.push("Self intersects");
      }
      let pointcount = {};
      CAG.sides.map(function(side) {
        function mappoint(p) {
          let tag = p.x + " " + p.y;
          if (!(tag in pointcount)) pointcount[tag] = 0;
          pointcount[tag]++;
        }
        mappoint(side.vertex0.pos);
        mappoint(side.vertex1.pos);
      });
      for (let tag in pointcount) {
        let count = pointcount[tag];
        if (count & 1) {
          errors.push("Uneven number of sides (" + count + ") for point " + tag);
        }
      }
      let area = CAG.area();
      if (area < areaEPS) {
        errors.push("Area is " + area);
      }
      if (errors.length > 0) {
        let ertxt = "";
        errors.map(function(err) {
          ertxt += err + "\n";
        });
        throw new Error(ertxt);
      }
    };
    var isSelfIntersecting = function(cag, debug) {
      let numsides = cag.sides.length;
      for (let i = 0; i < numsides; i++) {
        let side0 = cag.sides[i];
        for (let ii = i + 1; ii < numsides; ii++) {
          let side1 = cag.sides[ii];
          if (linesIntersect(side0.vertex0.pos, side0.vertex1.pos, side1.vertex0.pos, side1.vertex1.pos)) {
            if (debug) {
              console.log("side " + i + ": " + side0);
              console.log("side " + ii + ": " + side1);
            }
            return true;
          }
        }
      }
      return false;
    };
    var hasPointInside = function(cag, p0) {
      let p1 = null;
      let p2 = null;
      let inside = false;
      cag.sides.forEach((side) => {
        p1 = side.vertex0.pos;
        p2 = side.vertex1.pos;
        if (hasPointInside.c1(p0, p1, p2) && hasPointInside.c2(p0, p1, p2)) {
          inside = !inside;
        }
      });
      return inside;
    };
    hasPointInside.c1 = (p0, p1, p2) => p1.y > p0.y !== p2.y > p0.y;
    hasPointInside.c2 = (p0, p1, p2) => p0.x < (p2.x - p1.x) * (p0.y - p1.y) / (p2.y - p1.y) + p1.x;
    var contains = function(cag1, cag2) {
      for (let i = 0, il = cag2.sides.length; i < il; i++) {
        if (!hasPointInside(cag1, cag2.sides[i].vertex0.pos)) {
          return false;
        }
      }
      return true;
    };
    module.exports = {
      isCAGValid,
      isSelfIntersecting,
      hasPointInside,
      contains
    };
  }
});

// src/core/vendor/csg/src/api/ops-booleans.js
var require_ops_booleans = __commonJS({
  "src/core/vendor/csg/src/api/ops-booleans.js"(exports, module) {
    "use strict";
    var { isCAG } = require_utils();
    function union() {
      let options = {};
      const defaults = {
        extrude2d: false
      };
      let o;
      let i = 0;
      let a = arguments;
      if (a[0].length) a = a[0];
      if ("extrude2d" in a[0]) {
        options = Object.assign({}, defaults, a[0]);
        o = a[i++];
      }
      o = a[i++];
      if (typeof a[i] === "object" && isCAG(a[i]) && options.extrude2d) {
        o = a[i].extrude({ offset: [0, 0, 0.1] });
      }
      for (; i < a.length; i++) {
        let obj = a[i];
        if (typeof a[i] === "object" && isCAG(a[i]) && options.extrude2d) {
          obj = a[i].extrude({ offset: [0, 0, 0.1] });
        }
        o = o.union(obj);
      }
      return o;
    }
    function difference() {
      let object;
      let i = 0;
      let a = arguments;
      if (a[0].length) a = a[0];
      for (object = a[i++]; i < a.length; i++) {
        if (isCAG(a[i])) {
          object = object.subtract(a[i]);
        } else {
          object = object.subtract(a[i].setColor(1, 1, 0));
        }
      }
      return object;
    }
    function intersection() {
      let object;
      let i = 0;
      let a = arguments;
      if (a[0].length) a = a[0];
      for (object = a[i++]; i < a.length; i++) {
        if (isCAG(a[i])) {
          object = object.intersect(a[i]);
        } else {
          object = object.intersect(a[i].setColor(1, 1, 0));
        }
      }
      return object;
    }
    module.exports = {
      union,
      difference,
      intersection
    };
  }
});

// src/core/vendor/csg/src/core/CAGFactories.js
var require_CAGFactories = __commonJS({
  "src/core/vendor/csg/src/core/CAGFactories.js"(exports, module) {
    "use strict";
    var Side = require_Side();
    var Vector2D = require_Vector2();
    var Vertex2 = require_Vertex2();
    var { areaEPS } = require_constants();
    var { isSelfIntersecting, contains } = require_cagValidation();
    var { union, difference } = require_ops_booleans();
    var fromSides = function(sides) {
      const CAG = require_CAG();
      let cag = new CAG();
      cag.sides = sides;
      return cag;
    };
    var fromFakeCSG = function(csg) {
      let sides = csg.polygons.map(function(p) {
        return Side._fromFakePolygon(p);
      }).filter(function(s) {
        return s !== null;
      });
      return fromSides(sides);
    };
    var fromPoints = function(points) {
      if (!points) {
        throw new Error("points parameter must be defined");
      }
      if (!Array.isArray(points)) {
        throw new Error("points parameter must be an array");
      }
      if (points[0].x !== void 0 || typeof points[0][0] === "number") {
        return fromPointsArray(points);
      }
      if (typeof points[0][0] === "object") {
        return fromNestedPointsArray(points);
      }
      throw new Error("Unsupported points list format");
    };
    var fromPointsArray = function(points) {
      if (points.length < 3) {
        throw new Error("CAG shape needs at least 3 points");
      }
      let sides = [];
      let prevvertex = new Vertex2(new Vector2D(points[points.length - 1]));
      points.map(function(point) {
        let vertex = new Vertex2(new Vector2D(point));
        sides.push(new Side(prevvertex, vertex));
        prevvertex = vertex;
      });
      let result = fromSides(sides);
      if (isSelfIntersecting(result)) {
        throw new Error("Polygon is self intersecting!");
      }
      let area = result.area();
      if (Math.abs(area) < areaEPS) {
        throw new Error("Degenerate polygon!");
      }
      if (area < 0) {
        result = result.flipped();
      }
      return result.canonicalized();
    };
    var fromNestedPointsArray = function(points) {
      if (points.length === 1) {
        return fromPoints(points[0]);
      }
      let paths = [];
      points.forEach((path2) => {
        paths.push(fromPointsArray(path2));
      });
      let tree = {};
      paths.forEach((p1, i) => {
        paths.forEach((p2, y) => {
          if (p1 !== p2) {
            tree[i] || (tree[i] = { parents: [], isHole: false });
            tree[y] || (tree[y] = { parents: [], isHole: false });
            if (contains(p2, p1)) {
              tree[i].parents.push(y);
              tree[i].isHole = !!(tree[i].parents.length % 2);
              tree[y].isHole = !!(tree[y].parents.length % 2);
            }
          }
        });
      });
      let path = null;
      for (key in tree) {
        path = tree[key];
        if (path.isHole) {
          delete tree[key];
          path.parents.forEach((parentKey) => {
            paths[parentKey] = difference(paths[parentKey], paths[key]);
          });
        }
      }
      let cag = fromSides([]);
      for (key in tree) {
        cag = union(cag, paths[key]);
      }
      return cag;
    };
    var fromObject = function(obj) {
      let sides = obj.sides.map(function(s) {
        return Side.fromObject(s);
      });
      let cag = fromSides(sides);
      cag.isCanonicalized = obj.isCanonicalized;
      return cag;
    };
    var fromPointsNoCheck = function(points) {
      let sides = [];
      let prevpoint = new Vector2D(points[points.length - 1]);
      let prevvertex = new Vertex2(prevpoint);
      points.map(function(p) {
        let point = new Vector2D(p);
        let vertex = new Vertex2(point);
        let side = new Side(prevvertex, vertex);
        sides.push(side);
        prevvertex = vertex;
      });
      return fromSides(sides);
    };
    var fromPath2 = function(path) {
      if (!path.isClosed()) throw new Error("The path should be closed!");
      return fromPoints(path.getPoints());
    };
    var fromCompactBinary = function(bin) {
      if (bin["class"] !== "CAG") throw new Error("Not a CAG");
      let vertices = [];
      let vertexData = bin.vertexData;
      let numvertices = vertexData.length / 2;
      let arrayindex = 0;
      for (let vertexindex = 0; vertexindex < numvertices; vertexindex++) {
        let x = vertexData[arrayindex++];
        let y = vertexData[arrayindex++];
        let pos = new Vector2D(x, y);
        let vertex = new Vertex2(pos);
        vertices.push(vertex);
      }
      let sides = [];
      let numsides = bin.sideVertexIndices.length / 2;
      arrayindex = 0;
      for (let sideindex = 0; sideindex < numsides; sideindex++) {
        let vertexindex0 = bin.sideVertexIndices[arrayindex++];
        let vertexindex1 = bin.sideVertexIndices[arrayindex++];
        let side = new Side(vertices[vertexindex0], vertices[vertexindex1]);
        sides.push(side);
      }
      let cag = fromSides(sides);
      cag.isCanonicalized = true;
      return cag;
    };
    module.exports = {
      fromSides,
      fromObject,
      fromPoints,
      fromPointsNoCheck,
      fromPath2,
      fromFakeCSG,
      fromCompactBinary
    };
  }
});

// src/core/vendor/csg/src/core/FuzzyFactory.js
var require_FuzzyFactory = __commonJS({
  "src/core/vendor/csg/src/core/FuzzyFactory.js"(exports, module) {
    "use strict";
    var FuzzyFactory = function(numdimensions, tolerance) {
      this.lookuptable = {};
      this.multiplier = 1 / tolerance;
    };
    FuzzyFactory.prototype = {
      // let obj = f.lookupOrCreate([el1, el2, el3], function(elements) {/* create the new object */});
      // Performs a fuzzy lookup of the object with the specified elements.
      // If found, returns the existing object
      // If not found, calls the supplied callback function which should create a new object with
      // the specified properties. This object is inserted in the lookup database.
      lookupOrCreate: function(els, creatorCallback) {
        let hash = "";
        let multiplier = this.multiplier;
        els.forEach(function(el) {
          let valueQuantized = Math.round(el * multiplier);
          hash += valueQuantized + "/";
        });
        if (hash in this.lookuptable) {
          return this.lookuptable[hash];
        } else {
          let object = creatorCallback(els);
          let hashparts = els.map(function(el) {
            let q0 = Math.floor(el * multiplier);
            let q1 = q0 + 1;
            return ["" + q0 + "/", "" + q1 + "/"];
          });
          let numelements = els.length;
          let numhashes = 1 << numelements;
          for (let hashmask = 0; hashmask < numhashes; ++hashmask) {
            let hashmaskShifted = hashmask;
            hash = "";
            hashparts.forEach(function(hashpart) {
              hash += hashpart[hashmaskShifted & 1];
              hashmaskShifted >>= 1;
            });
            this.lookuptable[hash] = object;
          }
          return object;
        }
      }
    };
    module.exports = FuzzyFactory;
  }
});

// src/core/vendor/csg/src/core/FuzzyFactory3d.js
var require_FuzzyFactory3d = __commonJS({
  "src/core/vendor/csg/src/core/FuzzyFactory3d.js"(exports, module) {
    "use strict";
    var { EPS } = require_constants();
    var Polygon = require_Polygon3();
    var FuzzyFactory = require_FuzzyFactory();
    var FuzzyCSGFactory = function() {
      this.vertexfactory = new FuzzyFactory(3, EPS);
      this.planefactory = new FuzzyFactory(4, EPS);
      this.polygonsharedfactory = {};
    };
    FuzzyCSGFactory.prototype = {
      getPolygonShared: function(sourceshared) {
        let hash = sourceshared.getHash();
        if (hash in this.polygonsharedfactory) {
          return this.polygonsharedfactory[hash];
        } else {
          this.polygonsharedfactory[hash] = sourceshared;
          return sourceshared;
        }
      },
      getVertex: function(sourcevertex) {
        let elements = [sourcevertex.pos._x, sourcevertex.pos._y, sourcevertex.pos._z];
        let result = this.vertexfactory.lookupOrCreate(elements, function(els) {
          return sourcevertex;
        });
        return result;
      },
      getPlane: function(sourceplane) {
        let elements = [sourceplane.normal._x, sourceplane.normal._y, sourceplane.normal._z, sourceplane.w];
        let result = this.planefactory.lookupOrCreate(elements, function(els) {
          return sourceplane;
        });
        return result;
      },
      getPolygon: function(sourcepolygon) {
        let newplane = this.getPlane(sourcepolygon.plane);
        let newshared = this.getPolygonShared(sourcepolygon.shared);
        let _this = this;
        let newvertices = sourcepolygon.vertices.map(function(vertex) {
          return _this.getVertex(vertex);
        });
        let newverticesDedup = [];
        if (newvertices.length > 0) {
          let prevvertextag = newvertices[newvertices.length - 1].getTag();
          newvertices.forEach(function(vertex) {
            let vertextag = vertex.getTag();
            if (vertextag !== prevvertextag) {
              newverticesDedup.push(vertex);
            }
            prevvertextag = vertextag;
          });
        }
        if (newverticesDedup.length < 3) {
          newverticesDedup = [];
        }
        return new Polygon(newverticesDedup, newshared, newplane);
      }
    };
    module.exports = FuzzyCSGFactory;
  }
});

// src/core/vendor/csg/src/core/FuzzyFactory2d.js
var require_FuzzyFactory2d = __commonJS({
  "src/core/vendor/csg/src/core/FuzzyFactory2d.js"(exports, module) {
    "use strict";
    var FuzzyFactory = require_FuzzyFactory();
    var { EPS } = require_constants();
    var Side = require_Side();
    var FuzzyCAGFactory = function() {
      this.vertexfactory = new FuzzyFactory(2, EPS);
    };
    FuzzyCAGFactory.prototype = {
      getVertex: function(sourcevertex) {
        let elements = [sourcevertex.pos._x, sourcevertex.pos._y];
        let result = this.vertexfactory.lookupOrCreate(elements, function(els) {
          return sourcevertex;
        });
        return result;
      },
      getSide: function(sourceside) {
        let vertex0 = this.getVertex(sourceside.vertex0);
        let vertex1 = this.getVertex(sourceside.vertex1);
        return new Side(vertex0, vertex1);
      }
    };
    module.exports = FuzzyCAGFactory;
  }
});

// src/core/vendor/csg/src/core/utils/canonicalize.js
var require_canonicalize = __commonJS({
  "src/core/vendor/csg/src/core/utils/canonicalize.js"(exports, module) {
    "use strict";
    var { EPS } = require_constants();
    var FuzzyCSGFactory = require_FuzzyFactory3d();
    var FuzzyCAGFactory = require_FuzzyFactory2d();
    var { fromPolygons } = require_CSGFactories();
    var { fromSides } = require_CAGFactories();
    var canonicalize = function(csgOrCAG, options) {
      if (csgOrCAG.isCanonicalized) {
        return csgOrCAG;
      } else {
        if ("sides" in csgOrCAG) {
          return canonicalizeCAG(csgOrCAG, options);
        } else {
          return canonicalizeCSG(csgOrCAG, options);
        }
      }
    };
    var canonicalizeCSG = function(csg, options) {
      if (csg.isCanonicalized) {
        return csg;
      } else {
        const factory = new FuzzyCSGFactory();
        let result = CSGFromCSGFuzzyFactory(factory, csg);
        result.isCanonicalized = true;
        result.isRetesselated = csg.isRetesselated;
        result.properties = csg.properties;
        return result;
      }
    };
    var canonicalizeCAG = function(cag, options) {
      if (cag.isCanonicalized) {
        return cag;
      } else {
        let factory = new FuzzyCAGFactory();
        let result = CAGFromCAGFuzzyFactory(factory, cag);
        result.isCanonicalized = true;
        return result;
      }
    };
    var CSGFromCSGFuzzyFactory = function(factory, sourcecsg) {
      let _this = factory;
      let newpolygons = [];
      sourcecsg.polygons.forEach(function(polygon) {
        let newpolygon = _this.getPolygon(polygon);
        if (newpolygon.vertices.length >= 3) {
          newpolygons.push(newpolygon);
        }
      });
      return fromPolygons(newpolygons);
    };
    var CAGFromCAGFuzzyFactory = function(factory, sourcecag) {
      let _this = factory;
      let newsides = sourcecag.sides.map(function(side) {
        return _this.getSide(side);
      }).filter(function(side) {
        return side.length() > EPS;
      });
      return fromSides(newsides);
    };
    module.exports = canonicalize;
  }
});

// src/core/vendor/csg/src/core/math/reTesselateCoplanarPolygons.js
var require_reTesselateCoplanarPolygons = __commonJS({
  "src/core/vendor/csg/src/core/math/reTesselateCoplanarPolygons.js"(exports, module) {
    "use strict";
    var { EPS } = require_constants();
    var OrthoNormalBasis = require_OrthoNormalBasis();
    var { interpolateBetween2DPointsForY, insertSorted, fnNumberSort } = require_utils();
    var Vertex = require_Vertex3();
    var Vector2D = require_Vector2();
    var Line2D = require_Line2();
    var Polygon = require_Polygon3();
    var reTesselateCoplanarPolygons = function(sourcepolygons, destpolygons) {
      let numpolygons = sourcepolygons.length;
      if (numpolygons > 0) {
        let plane = sourcepolygons[0].plane;
        let shared = sourcepolygons[0].shared;
        let orthobasis = new OrthoNormalBasis(plane);
        let polygonvertices2d = [];
        let polygontopvertexindexes = [];
        let topy2polygonindexes = {};
        let ycoordinatetopolygonindexes = {};
        let xcoordinatebins = {};
        let ycoordinatebins = {};
        let ycoordinateBinningFactor = 1 / EPS * 10;
        for (let polygonindex = 0; polygonindex < numpolygons; polygonindex++) {
          let poly3d = sourcepolygons[polygonindex];
          let vertices2d = [];
          let numvertices = poly3d.vertices.length;
          let minindex = -1;
          if (numvertices > 0) {
            let miny, maxy, maxindex;
            for (let i = 0; i < numvertices; i++) {
              let pos2d = orthobasis.to2D(poly3d.vertices[i].pos);
              let ycoordinatebin = Math.floor(pos2d.y * ycoordinateBinningFactor);
              let newy;
              if (ycoordinatebin in ycoordinatebins) {
                newy = ycoordinatebins[ycoordinatebin];
              } else if (ycoordinatebin + 1 in ycoordinatebins) {
                newy = ycoordinatebins[ycoordinatebin + 1];
              } else if (ycoordinatebin - 1 in ycoordinatebins) {
                newy = ycoordinatebins[ycoordinatebin - 1];
              } else {
                newy = pos2d.y;
                ycoordinatebins[ycoordinatebin] = pos2d.y;
              }
              pos2d = Vector2D.Create(pos2d.x, newy);
              vertices2d.push(pos2d);
              let y = pos2d.y;
              if (i === 0 || y < miny) {
                miny = y;
                minindex = i;
              }
              if (i === 0 || y > maxy) {
                maxy = y;
                maxindex = i;
              }
              if (!(y in ycoordinatetopolygonindexes)) {
                ycoordinatetopolygonindexes[y] = {};
              }
              ycoordinatetopolygonindexes[y][polygonindex] = true;
            }
            if (miny >= maxy) {
              vertices2d = [];
              numvertices = 0;
              minindex = -1;
            } else {
              if (!(miny in topy2polygonindexes)) {
                topy2polygonindexes[miny] = [];
              }
              topy2polygonindexes[miny].push(polygonindex);
            }
          }
          vertices2d.reverse();
          minindex = numvertices - minindex - 1;
          polygonvertices2d.push(vertices2d);
          polygontopvertexindexes.push(minindex);
        }
        let ycoordinates = [];
        for (let ycoordinate in ycoordinatetopolygonindexes) ycoordinates.push(ycoordinate);
        ycoordinates.sort(fnNumberSort);
        let activepolygons = [];
        let prevoutpolygonrow = [];
        for (let yindex = 0; yindex < ycoordinates.length; yindex++) {
          let newoutpolygonrow = [];
          let ycoordinate_as_string = ycoordinates[yindex];
          let ycoordinate = Number(ycoordinate_as_string);
          let polygonindexeswithcorner = ycoordinatetopolygonindexes[ycoordinate_as_string];
          for (let activepolygonindex = 0; activepolygonindex < activepolygons.length; ++activepolygonindex) {
            let activepolygon = activepolygons[activepolygonindex];
            let polygonindex = activepolygon.polygonindex;
            if (polygonindexeswithcorner[polygonindex]) {
              let vertices2d = polygonvertices2d[polygonindex];
              let numvertices = vertices2d.length;
              let newleftvertexindex = activepolygon.leftvertexindex;
              let newrightvertexindex = activepolygon.rightvertexindex;
              while (true) {
                let nextleftvertexindex = newleftvertexindex + 1;
                if (nextleftvertexindex >= numvertices) nextleftvertexindex = 0;
                if (vertices2d[nextleftvertexindex].y !== ycoordinate) break;
                newleftvertexindex = nextleftvertexindex;
              }
              let nextrightvertexindex = newrightvertexindex - 1;
              if (nextrightvertexindex < 0) nextrightvertexindex = numvertices - 1;
              if (vertices2d[nextrightvertexindex].y === ycoordinate) {
                newrightvertexindex = nextrightvertexindex;
              }
              if (newleftvertexindex !== activepolygon.leftvertexindex && newleftvertexindex === newrightvertexindex) {
                activepolygons.splice(activepolygonindex, 1);
                --activepolygonindex;
              } else {
                activepolygon.leftvertexindex = newleftvertexindex;
                activepolygon.rightvertexindex = newrightvertexindex;
                activepolygon.topleft = vertices2d[newleftvertexindex];
                activepolygon.topright = vertices2d[newrightvertexindex];
                let nextleftvertexindex = newleftvertexindex + 1;
                if (nextleftvertexindex >= numvertices) nextleftvertexindex = 0;
                activepolygon.bottomleft = vertices2d[nextleftvertexindex];
                let nextrightvertexindex2 = newrightvertexindex - 1;
                if (nextrightvertexindex2 < 0) nextrightvertexindex2 = numvertices - 1;
                activepolygon.bottomright = vertices2d[nextrightvertexindex2];
              }
            }
          }
          let nextycoordinate;
          if (yindex >= ycoordinates.length - 1) {
            activepolygons = [];
            nextycoordinate = null;
          } else {
            nextycoordinate = Number(ycoordinates[yindex + 1]);
            let middleycoordinate = 0.5 * (ycoordinate + nextycoordinate);
            let startingpolygonindexes = topy2polygonindexes[ycoordinate_as_string];
            for (let polygonindex_key in startingpolygonindexes) {
              let polygonindex = startingpolygonindexes[polygonindex_key];
              let vertices2d = polygonvertices2d[polygonindex];
              let numvertices = vertices2d.length;
              let topvertexindex = polygontopvertexindexes[polygonindex];
              let topleftvertexindex = topvertexindex;
              while (true) {
                let i = topleftvertexindex + 1;
                if (i >= numvertices) i = 0;
                if (vertices2d[i].y !== ycoordinate) break;
                if (i === topvertexindex) break;
                topleftvertexindex = i;
              }
              let toprightvertexindex = topvertexindex;
              while (true) {
                let i = toprightvertexindex - 1;
                if (i < 0) i = numvertices - 1;
                if (vertices2d[i].y !== ycoordinate) break;
                if (i === topleftvertexindex) break;
                toprightvertexindex = i;
              }
              let nextleftvertexindex = topleftvertexindex + 1;
              if (nextleftvertexindex >= numvertices) nextleftvertexindex = 0;
              let nextrightvertexindex = toprightvertexindex - 1;
              if (nextrightvertexindex < 0) nextrightvertexindex = numvertices - 1;
              let newactivepolygon = {
                polygonindex,
                leftvertexindex: topleftvertexindex,
                rightvertexindex: toprightvertexindex,
                topleft: vertices2d[topleftvertexindex],
                topright: vertices2d[toprightvertexindex],
                bottomleft: vertices2d[nextleftvertexindex],
                bottomright: vertices2d[nextrightvertexindex]
              };
              insertSorted(activepolygons, newactivepolygon, function(el1, el2) {
                let x1 = interpolateBetween2DPointsForY(
                  el1.topleft,
                  el1.bottomleft,
                  middleycoordinate
                );
                let x2 = interpolateBetween2DPointsForY(
                  el2.topleft,
                  el2.bottomleft,
                  middleycoordinate
                );
                if (x1 > x2) return 1;
                if (x1 < x2) return -1;
                return 0;
              });
            }
          }
          if (true) {
            for (let activepolygonKey in activepolygons) {
              let activepolygon = activepolygons[activepolygonKey];
              let polygonindex = activepolygon.polygonindex;
              let vertices2d = polygonvertices2d[polygonindex];
              let numvertices = vertices2d.length;
              let x = interpolateBetween2DPointsForY(activepolygon.topleft, activepolygon.bottomleft, ycoordinate);
              let topleft = Vector2D.Create(x, ycoordinate);
              x = interpolateBetween2DPointsForY(activepolygon.topright, activepolygon.bottomright, ycoordinate);
              let topright = Vector2D.Create(x, ycoordinate);
              x = interpolateBetween2DPointsForY(activepolygon.topleft, activepolygon.bottomleft, nextycoordinate);
              let bottomleft = Vector2D.Create(x, nextycoordinate);
              x = interpolateBetween2DPointsForY(activepolygon.topright, activepolygon.bottomright, nextycoordinate);
              let bottomright = Vector2D.Create(x, nextycoordinate);
              let outpolygon = {
                topleft,
                topright,
                bottomleft,
                bottomright,
                leftline: Line2D.fromPoints(topleft, bottomleft),
                rightline: Line2D.fromPoints(bottomright, topright)
              };
              if (newoutpolygonrow.length > 0) {
                let prevoutpolygon = newoutpolygonrow[newoutpolygonrow.length - 1];
                let d1 = outpolygon.topleft.distanceTo(prevoutpolygon.topright);
                let d2 = outpolygon.bottomleft.distanceTo(prevoutpolygon.bottomright);
                if (d1 < EPS && d2 < EPS) {
                  outpolygon.topleft = prevoutpolygon.topleft;
                  outpolygon.leftline = prevoutpolygon.leftline;
                  outpolygon.bottomleft = prevoutpolygon.bottomleft;
                  newoutpolygonrow.splice(newoutpolygonrow.length - 1, 1);
                }
              }
              newoutpolygonrow.push(outpolygon);
            }
            if (yindex > 0) {
              let prevcontinuedindexes = {};
              let matchedindexes = {};
              for (let i = 0; i < newoutpolygonrow.length; i++) {
                let thispolygon = newoutpolygonrow[i];
                for (let ii = 0; ii < prevoutpolygonrow.length; ii++) {
                  if (!matchedindexes[ii]) {
                    let prevpolygon = prevoutpolygonrow[ii];
                    if (prevpolygon.bottomleft.distanceTo(thispolygon.topleft) < EPS) {
                      if (prevpolygon.bottomright.distanceTo(thispolygon.topright) < EPS) {
                        matchedindexes[ii] = true;
                        let d1 = thispolygon.leftline.direction().x - prevpolygon.leftline.direction().x;
                        let d2 = thispolygon.rightline.direction().x - prevpolygon.rightline.direction().x;
                        let leftlinecontinues = Math.abs(d1) < EPS;
                        let rightlinecontinues = Math.abs(d2) < EPS;
                        let leftlineisconvex = leftlinecontinues || d1 >= 0;
                        let rightlineisconvex = rightlinecontinues || d2 >= 0;
                        if (leftlineisconvex && rightlineisconvex) {
                          thispolygon.outpolygon = prevpolygon.outpolygon;
                          thispolygon.leftlinecontinues = leftlinecontinues;
                          thispolygon.rightlinecontinues = rightlinecontinues;
                          prevcontinuedindexes[ii] = true;
                        }
                        break;
                      }
                    }
                  }
                }
              }
              for (let ii = 0; ii < prevoutpolygonrow.length; ii++) {
                if (!prevcontinuedindexes[ii]) {
                  let prevpolygon = prevoutpolygonrow[ii];
                  prevpolygon.outpolygon.rightpoints.push(prevpolygon.bottomright);
                  if (prevpolygon.bottomright.distanceTo(prevpolygon.bottomleft) > EPS) {
                    prevpolygon.outpolygon.leftpoints.push(prevpolygon.bottomleft);
                  }
                  prevpolygon.outpolygon.leftpoints.reverse();
                  let points2d = prevpolygon.outpolygon.rightpoints.concat(prevpolygon.outpolygon.leftpoints);
                  let vertices3d = [];
                  points2d.map(function(point2d) {
                    let point3d = orthobasis.to3D(point2d);
                    let vertex3d = new Vertex(point3d);
                    vertices3d.push(vertex3d);
                  });
                  let polygon = new Polygon(vertices3d, shared, plane);
                  destpolygons.push(polygon);
                }
              }
            }
            for (let i = 0; i < newoutpolygonrow.length; i++) {
              let thispolygon = newoutpolygonrow[i];
              if (!thispolygon.outpolygon) {
                thispolygon.outpolygon = {
                  leftpoints: [],
                  rightpoints: []
                };
                thispolygon.outpolygon.leftpoints.push(thispolygon.topleft);
                if (thispolygon.topleft.distanceTo(thispolygon.topright) > EPS) {
                  thispolygon.outpolygon.rightpoints.push(thispolygon.topright);
                }
              } else {
                if (!thispolygon.leftlinecontinues) {
                  thispolygon.outpolygon.leftpoints.push(thispolygon.topleft);
                }
                if (!thispolygon.rightlinecontinues) {
                  thispolygon.outpolygon.rightpoints.push(thispolygon.topright);
                }
              }
            }
            prevoutpolygonrow = newoutpolygonrow;
          }
        }
      }
    };
    module.exports = reTesselateCoplanarPolygons;
  }
});

// src/core/vendor/csg/src/core/utils/retesellate.js
var require_retesellate = __commonJS({
  "src/core/vendor/csg/src/core/utils/retesellate.js"(exports, module) {
    "use strict";
    var FuzzyCSGFactory = require_FuzzyFactory3d();
    var reTesselateCoplanarPolygons = require_reTesselateCoplanarPolygons();
    var { fromPolygons } = require_CSGFactories();
    var reTesselate = function(csg) {
      if (csg.isRetesselated) {
        return csg;
      } else {
        let polygonsPerPlane = {};
        let isCanonicalized = csg.isCanonicalized;
        let fuzzyfactory = new FuzzyCSGFactory();
        csg.polygons.map(function(polygon) {
          let plane = polygon.plane;
          let shared = polygon.shared;
          if (!isCanonicalized) {
            plane = fuzzyfactory.getPlane(plane);
            shared = fuzzyfactory.getPolygonShared(shared);
          }
          let tag = plane.getTag() + "/" + shared.getTag();
          if (!(tag in polygonsPerPlane)) {
            polygonsPerPlane[tag] = [polygon];
          } else {
            polygonsPerPlane[tag].push(polygon);
          }
        });
        let destpolygons = [];
        for (let planetag in polygonsPerPlane) {
          let sourcepolygons = polygonsPerPlane[planetag];
          if (sourcepolygons.length < 2) {
            destpolygons = destpolygons.concat(sourcepolygons);
          } else {
            let retesselayedpolygons = [];
            reTesselateCoplanarPolygons(sourcepolygons, retesselayedpolygons);
            destpolygons = destpolygons.concat(retesselayedpolygons);
          }
        }
        let result = fromPolygons(destpolygons);
        result.isRetesselated = true;
        result.properties = csg.properties;
        return result;
      }
    };
    module.exports = reTesselate;
  }
});

// src/core/vendor/csg/src/core/utils/cagMeasurements.js
var require_cagMeasurements = __commonJS({
  "src/core/vendor/csg/src/core/utils/cagMeasurements.js"(exports, module) {
    "use strict";
    var Vector2D = require_Vector2();
    var area = function(cag) {
      let polygonArea = 0;
      cag.sides.map(function(side) {
        polygonArea += side.vertex0.pos.cross(side.vertex1.pos);
      });
      polygonArea *= 0.5;
      return polygonArea;
    };
    var getBounds = function(cag) {
      let minpoint;
      if (cag.sides.length === 0) {
        minpoint = new Vector2D(0, 0);
      } else {
        minpoint = cag.sides[0].vertex0.pos;
      }
      let maxpoint = minpoint;
      cag.sides.map(function(side) {
        minpoint = minpoint.min(side.vertex0.pos);
        minpoint = minpoint.min(side.vertex1.pos);
        maxpoint = maxpoint.max(side.vertex0.pos);
        maxpoint = maxpoint.max(side.vertex1.pos);
      });
      return [minpoint, maxpoint];
    };
    module.exports = { area, getBounds };
  }
});

// src/core/vendor/csg/src/api/ops-cnc.js
var require_ops_cnc = __commonJS({
  "src/core/vendor/csg/src/api/ops-cnc.js"(exports, module) {
    "use strict";
    var Matrix4x4 = require_Matrix4();
    var Vector3D = require_Vector3();
    var { Connector } = require_connectors();
    var { fromPoints } = require_CAGFactories();
    var Vector2D = require_Vector2();
    var getTransformationAndInverseTransformationToFlatLying = function(_csg) {
      if (_csg.polygons.length === 0) {
        let m = new Matrix4x4();
        return [m, m];
      } else {
        let csg = _csg.canonicalized();
        let planemap = {};
        csg.polygons.map(function(polygon) {
          planemap[polygon.plane.getTag()] = polygon.plane;
        });
        let xvector = new Vector3D(1, 0, 0);
        let yvector = new Vector3D(0, 1, 0);
        let zvector = new Vector3D(0, 0, 1);
        let z0connectorx = new Connector([0, 0, 0], [0, 0, -1], xvector);
        let z0connectory = new Connector([0, 0, 0], [0, 0, -1], yvector);
        let isfirst = true;
        let minheight = 0;
        let maxdotz = 0;
        let besttransformation, bestinversetransformation;
        for (let planetag in planemap) {
          let plane = planemap[planetag];
          let pointonplane = plane.normal.times(plane.w);
          let transformation, inversetransformation;
          let xorthogonality = plane.normal.cross(xvector).length();
          let yorthogonality = plane.normal.cross(yvector).length();
          if (xorthogonality > yorthogonality) {
            let planeconnector = new Connector(pointonplane, plane.normal, xvector);
            transformation = planeconnector.getTransformationTo(z0connectorx, false, 0);
            inversetransformation = z0connectorx.getTransformationTo(planeconnector, false, 0);
          } else {
            let planeconnector = new Connector(pointonplane, plane.normal, yvector);
            transformation = planeconnector.getTransformationTo(z0connectory, false, 0);
            inversetransformation = z0connectory.getTransformationTo(planeconnector, false, 0);
          }
          let transformedcsg = csg.transform(transformation);
          let dotz = -plane.normal.dot(zvector);
          let bounds = transformedcsg.getBounds();
          let zheight = bounds[1].z - bounds[0].z;
          let isbetter = isfirst;
          if (!isbetter) {
            if (zheight < minheight) {
              isbetter = true;
            } else if (zheight === minheight) {
              if (dotz > maxdotz) isbetter = true;
            }
          }
          if (isbetter) {
            let translation = new Vector3D([-0.5 * (bounds[1].x + bounds[0].x), -0.5 * (bounds[1].y + bounds[0].y), -bounds[0].z]);
            transformation = transformation.multiply(Matrix4x4.translation(translation));
            inversetransformation = Matrix4x4.translation(translation.negated()).multiply(inversetransformation);
            minheight = zheight;
            maxdotz = dotz;
            besttransformation = transformation;
            bestinversetransformation = inversetransformation;
          }
          isfirst = false;
        }
        return [besttransformation, bestinversetransformation];
      }
    };
    var getTransformationToFlatLying = function(csg) {
      let result = csg.getTransformationAndInverseTransformationToFlatLying();
      return result[0];
    };
    var lieFlat = function(csg) {
      let transformation = csg.getTransformationToFlatLying();
      return csg.transform(transformation);
    };
    var overCutInsideCorners = function(_cag, cutterradius) {
      let cag = _cag.canonicalized();
      let pointmap = {};
      cag.sides.map(function(side) {
        if (!(side.vertex0.getTag() in pointmap)) {
          pointmap[side.vertex0.getTag()] = {
            pos: side.vertex0.pos,
            from: [],
            to: []
          };
        }
        pointmap[side.vertex0.getTag()].to.push(side.vertex1.pos);
        if (!(side.vertex1.getTag() in pointmap)) {
          pointmap[side.vertex1.getTag()] = {
            pos: side.vertex1.pos,
            from: [],
            to: []
          };
        }
        pointmap[side.vertex1.getTag()].from.push(side.vertex0.pos);
      });
      let cutouts = [];
      for (let pointtag in pointmap) {
        let pointobj = pointmap[pointtag];
        if (pointobj.from.length === 1 && pointobj.to.length === 1) {
          let fromcoord = pointobj.from[0];
          let pointcoord = pointobj.pos;
          let tocoord = pointobj.to[0];
          let v1 = pointcoord.minus(fromcoord).unit();
          let v2 = tocoord.minus(pointcoord).unit();
          let crossproduct = v1.cross(v2);
          let isInnerCorner = crossproduct < 1e-3;
          if (isInnerCorner) {
            let alpha = v2.angleRadians() - v1.angleRadians() + Math.PI;
            if (alpha < 0) {
              alpha += 2 * Math.PI;
            } else if (alpha >= 2 * Math.PI) {
              alpha -= 2 * Math.PI;
            }
            let midvector = v2.minus(v1).unit();
            let circlesegmentangle = 30 / 180 * Math.PI;
            let radiuscorrected = cutterradius / Math.cos(circlesegmentangle / 2);
            let circlecenter = pointcoord.plus(midvector.times(radiuscorrected));
            let startangle = alpha + midvector.angleRadians();
            let deltaangle = 2 * (Math.PI - alpha);
            let numsteps = 2 * Math.ceil(deltaangle / circlesegmentangle / 2);
            let points = [circlecenter];
            for (let i = 0; i <= numsteps; i++) {
              let angle = startangle + i / numsteps * deltaangle;
              let p = Vector2D.fromAngleRadians(angle).times(radiuscorrected).plus(circlecenter);
              points.push(p);
            }
            cutouts.push(fromPoints(points));
          }
        }
      }
      return cag.subtract(cutouts);
    };
    module.exports = { lieFlat, getTransformationToFlatLying, getTransformationAndInverseTransformationToFlatLying, overCutInsideCorners };
  }
});

// src/core/vendor/csg/src/api/optionParsers.js
var require_optionParsers = __commonJS({
  "src/core/vendor/csg/src/api/optionParsers.js"(exports, module) {
    "use strict";
    var Vector3D = require_Vector3();
    var Vector2D = require_Vector2();
    var parseOption = function(options, optionname, defaultvalue) {
      var result = defaultvalue;
      if (options && optionname in options) {
        result = options[optionname];
      }
      return result;
    };
    var parseOptionAs3DVector = function(options, optionname, defaultvalue) {
      var result = parseOption(options, optionname, defaultvalue);
      result = new Vector3D(result);
      return result;
    };
    var parseOptionAs3DVectorList = function(options, optionname, defaultvalue) {
      var result = parseOption(options, optionname, defaultvalue);
      return result.map(function(res) {
        return new Vector3D(res);
      });
    };
    var parseOptionAs2DVector = function(options, optionname, defaultvalue) {
      var result = parseOption(options, optionname, defaultvalue);
      result = new Vector2D(result);
      return result;
    };
    var parseOptionAsFloat = function(options, optionname, defaultvalue) {
      var result = parseOption(options, optionname, defaultvalue);
      if (typeof result === "string") {
        result = Number(result);
      }
      if (isNaN(result) || typeof result !== "number") {
        throw new Error("Parameter " + optionname + " should be a number");
      }
      return result;
    };
    var parseOptionAsInt = function(options, optionname, defaultvalue) {
      var result = parseOption(options, optionname, defaultvalue);
      result = Number(Math.floor(result));
      if (isNaN(result)) {
        throw new Error("Parameter " + optionname + " should be a number");
      }
      return result;
    };
    var parseOptionAsBool = function(options, optionname, defaultvalue) {
      var result = parseOption(options, optionname, defaultvalue);
      if (typeof result === "string") {
        if (result === "true") result = true;
        else if (result === "false") result = false;
        else if (result === 0) result = false;
      }
      result = !!result;
      return result;
    };
    module.exports = {
      parseOption,
      parseOptionAsInt,
      parseOptionAsFloat,
      parseOptionAsBool,
      parseOptionAs3DVector,
      parseOptionAs2DVector,
      parseOptionAs3DVectorList
    };
  }
});

// src/core/vendor/csg/src/core/math/Path2.js
var require_Path2 = __commonJS({
  "src/core/vendor/csg/src/core/math/Path2.js"(exports, module) {
    "use strict";
    var Vector2D = require_Vector2();
    var { EPS, angleEPS } = require_constants();
    var { parseOptionAs2DVector, parseOptionAsFloat, parseOptionAsInt, parseOptionAsBool } = require_optionParsers();
    var { defaultResolution2D } = require_constants();
    var Vertex = require_Vertex2();
    var Side = require_Side();
    var Path2D = function(points, closed) {
      closed = !!closed;
      points = points || [];
      let prevpoint = null;
      if (closed && points.length > 0) {
        prevpoint = new Vector2D(points[points.length - 1]);
      }
      let newpoints = [];
      points.map(function(point) {
        point = new Vector2D(point);
        let skip = false;
        if (prevpoint !== null) {
          let distance = point.distanceTo(prevpoint);
          skip = distance < EPS;
        }
        if (!skip) newpoints.push(point);
        prevpoint = point;
      });
      this.points = newpoints;
      this.closed = closed;
    };
    Path2D.arc = function(options) {
      let center = parseOptionAs2DVector(options, "center", 0);
      let radius = parseOptionAsFloat(options, "radius", 1);
      let startangle = parseOptionAsFloat(options, "startangle", 0);
      let endangle = parseOptionAsFloat(options, "endangle", 360);
      let resolution = parseOptionAsInt(options, "resolution", defaultResolution2D);
      let maketangent = parseOptionAsBool(options, "maketangent", false);
      while (endangle - startangle >= 720) {
        endangle -= 360;
      }
      while (endangle - startangle <= -720) {
        endangle += 360;
      }
      let points = [];
      let point;
      let absangledif = Math.abs(endangle - startangle);
      if (absangledif < angleEPS) {
        point = Vector2D.fromAngle(startangle / 180 * Math.PI).times(radius);
        points.push(point.plus(center));
      } else {
        let numsteps = Math.floor(resolution * absangledif / 360) + 1;
        let edgestepsize = numsteps * 0.5 / absangledif;
        if (edgestepsize > 0.25) edgestepsize = 0.25;
        let numstepsMod = maketangent ? numsteps + 2 : numsteps;
        for (let i = 0; i <= numstepsMod; i++) {
          let step = i;
          if (maketangent) {
            step = (i - 1) * (numsteps - 2 * edgestepsize) / numsteps + edgestepsize;
            if (step < 0) step = 0;
            if (step > numsteps) step = numsteps;
          }
          let angle = startangle + step * (endangle - startangle) / numsteps;
          point = Vector2D.fromAngle(angle / 180 * Math.PI).times(radius);
          points.push(point.plus(center));
        }
      }
      return new Path2D(points, false);
    };
    Path2D.prototype = {
      concat: function(otherpath) {
        if (this.closed || otherpath.closed) {
          throw new Error("Paths must not be closed");
        }
        let newpoints = this.points.concat(otherpath.points);
        return new Path2D(newpoints);
      },
      /**
       * Get the points that make up the path.
       * note that this is current internal list of points, not an immutable copy.
       * @returns {Vector2[]} array of points the make up the path
       */
      getPoints: function() {
        return this.points;
      },
      /**
       * Append an point to the end of the path.
       * @param {Vector2D} point - point to append
       * @returns {Path2D} new Path2D object (not closed)
       */
      appendPoint: function(point) {
        if (this.closed) {
          throw new Error("Path must not be closed");
        }
        point = new Vector2D(point);
        let newpoints = this.points.concat([point]);
        return new Path2D(newpoints);
      },
      /**
       * Append a list of points to the end of the path.
       * @param {Vector2D[]} points - points to append
       * @returns {Path2D} new Path2D object (not closed)
       */
      appendPoints: function(points) {
        if (this.closed) {
          throw new Error("Path must not be closed");
        }
        let newpoints = this.points;
        points.forEach(function(point) {
          newpoints.push(new Vector2D(point));
        });
        return new Path2D(newpoints);
      },
      close: function() {
        return new Path2D(this.points, true);
      },
      /**
       * Determine if the path is a closed or not.
       * @returns {Boolean} true when the path is closed, otherwise false
       */
      isClosed: function() {
        return this.closed;
      },
      /**
       * Determine the overall clockwise or anti-clockwise turn of a path.
       * See: http://mathworld.wolfram.com/PolygonArea.html
       * @returns {String} One of ['clockwise', 'counter-clockwise', 'straight'].
       */
      getTurn: function() {
        const points = this.points;
        let twice_area = 0;
        let last = points.length - 1;
        for (let current = 0; current < points.length; last = current++) {
          twice_area += points[last].x * points[current].y - points[last].y * points[current].x;
        }
        if (twice_area > 0) {
          return "clockwise";
        } else if (twice_area < 0) {
          return "counter-clockwise";
        } else {
          return "straight";
        }
      },
      // Extrude the path by following it with a rectangle (upright, perpendicular to the path direction)
      // Returns a CSG solid
      //   width: width of the extrusion, in the z=0 plane
      //   height: height of the extrusion in the z direction
      //   resolution: number of segments per 360 degrees for the curve in a corner
      rectangularExtrude: function(width, height, resolution) {
        let cag = this.expandToCAG(width / 2, resolution);
        let result = cag.extrude({
          offset: [0, 0, height]
        });
        return result;
      },
      // Expand the path to a CAG
      // This traces the path with a circle with radius pathradius
      expandToCAG: function(pathradius, resolution) {
        const CAG = require_CAG();
        let sides = [];
        let numpoints = this.points.length;
        let startindex = 0;
        if (this.closed && numpoints > 2) startindex = -1;
        let prevvertex;
        for (let i = startindex; i < numpoints; i++) {
          let pointindex = i;
          if (pointindex < 0) pointindex = numpoints - 1;
          let point = this.points[pointindex];
          let vertex = new Vertex(point);
          if (i > startindex) {
            let side = new Side(prevvertex, vertex);
            sides.push(side);
          }
          prevvertex = vertex;
        }
        let shellcag = CAG.fromSides(sides);
        let expanded = shellcag.expandedShell(pathradius, resolution);
        return expanded;
      },
      innerToCAG: function() {
        const CAG = require_CAG();
        if (!this.closed) throw new Error("The path should be closed!");
        return CAG.fromPoints(this.points);
      },
      transform: function(matrix4x4) {
        let newpoints = this.points.map(function(point) {
          return point.multiply4x4(matrix4x4);
        });
        return new Path2D(newpoints, this.closed);
      },
      /**
       * Append a Bezier curve to the end of the path, using the control points to transition the curve through start and end points.
       * <br>
       * The Bzier curve starts at the last point in the path,
       * and ends at the last given control point. Other control points are intermediate control points.
       * <br>
       * The first control point may be null to ensure a smooth transition occurs. In this case,
       * the second to last control point of the path is mirrored into the control points of the Bezier curve.
       * In other words, the trailing gradient of the path matches the new gradient of the curve.
       * @param {Vector2D[]} controlpoints - list of control points
       * @param {Object} [options] - options for construction
       * @param {Number} [options.resolution=defaultResolution2D] - number of sides per 360 rotation
       * @returns {Path2D} new Path2D object (not closed)
       *
       * @example
       * let p5 = new CSG.Path2D([[10,-20]],false);
       * p5 = p5.appendBezier([[10,-10],[25,-10],[25,-20]]);
       * p5 = p5.appendBezier([[25,-30],[40,-30],[40,-20]]);
       */
      appendBezier: function(controlpoints, options) {
        if (arguments.length < 2) {
          options = {};
        }
        if (this.closed) {
          throw new Error("Path must not be closed");
        }
        if (!(controlpoints instanceof Array)) {
          throw new Error("appendBezier: should pass an array of control points");
        }
        if (controlpoints.length < 1) {
          throw new Error("appendBezier: need at least 1 control point");
        }
        if (this.points.length < 1) {
          throw new Error("appendBezier: path must already contain a point (the endpoint of the path is used as the starting point for the bezier curve)");
        }
        let resolution = parseOptionAsInt(options, "resolution", defaultResolution2D);
        if (resolution < 4) resolution = 4;
        let factorials = [];
        let controlpointsParsed = [];
        controlpointsParsed.push(this.points[this.points.length - 1]);
        for (let i = 0; i < controlpoints.length; ++i) {
          let p = controlpoints[i];
          if (p === null) {
            if (i !== 0) {
              throw new Error("appendBezier: null can only be passed as the first control point");
            }
            if (controlpoints.length < 2) {
              throw new Error("appendBezier: null can only be passed if there is at least one more control point");
            }
            let lastBezierControlPoint;
            if ("lastBezierControlPoint" in this) {
              lastBezierControlPoint = this.lastBezierControlPoint;
            } else {
              if (this.points.length < 2) {
                throw new Error("appendBezier: null is passed as a control point but this requires a previous bezier curve or at least two points in the existing path");
              }
              lastBezierControlPoint = this.points[this.points.length - 2];
            }
            p = this.points[this.points.length - 1].times(2).minus(lastBezierControlPoint);
          } else {
            p = new Vector2D(p);
          }
          controlpointsParsed.push(p);
        }
        let bezierOrder = controlpointsParsed.length - 1;
        let fact = 1;
        for (let i = 0; i <= bezierOrder; ++i) {
          if (i > 0) fact *= i;
          factorials.push(fact);
        }
        let binomials = [];
        for (let i = 0; i <= bezierOrder; ++i) {
          let binomial = factorials[bezierOrder] / (factorials[i] * factorials[bezierOrder - i]);
          binomials.push(binomial);
        }
        let getPointForT = function(t) {
          let t_k = 1;
          let one_minus_t_n_minus_k = Math.pow(1 - t, bezierOrder);
          let inv_1_minus_t = t !== 1 ? 1 / (1 - t) : 1;
          let point = new Vector2D(0, 0);
          for (let k = 0; k <= bezierOrder; ++k) {
            if (k === bezierOrder) one_minus_t_n_minus_k = 1;
            let bernstein_coefficient = binomials[k] * t_k * one_minus_t_n_minus_k;
            point = point.plus(controlpointsParsed[k].times(bernstein_coefficient));
            t_k *= t;
            one_minus_t_n_minus_k *= inv_1_minus_t;
          }
          return point;
        };
        let newpoints = [];
        let newpoints_t = [];
        let numsteps = bezierOrder + 1;
        for (let i = 0; i < numsteps; ++i) {
          let t = i / (numsteps - 1);
          let point = getPointForT(t);
          newpoints.push(point);
          newpoints_t.push(t);
        }
        let subdivideBase = 1;
        let maxangle = Math.PI * 2 / resolution;
        let maxsinangle = Math.sin(maxangle);
        while (subdivideBase < newpoints.length - 1) {
          let dir1 = newpoints[subdivideBase].minus(newpoints[subdivideBase - 1]).unit();
          let dir2 = newpoints[subdivideBase + 1].minus(newpoints[subdivideBase]).unit();
          let sinangle = dir1.cross(dir2);
          if (Math.abs(sinangle) > maxsinangle) {
            let t0 = newpoints_t[subdivideBase - 1];
            let t1 = newpoints_t[subdivideBase + 1];
            let t0_new = t0 + (t1 - t0) * 1 / 3;
            let t1_new = t0 + (t1 - t0) * 2 / 3;
            let point0_new = getPointForT(t0_new);
            let point1_new = getPointForT(t1_new);
            newpoints.splice(subdivideBase, 1, point0_new, point1_new);
            newpoints_t.splice(subdivideBase, 1, t0_new, t1_new);
            subdivideBase--;
            if (subdivideBase < 1) subdivideBase = 1;
          } else {
            ++subdivideBase;
          }
        }
        newpoints = this.points.concat(newpoints.slice(1));
        let result = new Path2D(newpoints);
        result.lastBezierControlPoint = controlpointsParsed[controlpointsParsed.length - 2];
        return result;
      },
      /**
       * Append an arc to the end of the path.
       * This implementation follows the SVG arc specs. For the details see
       * http://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands
       * @param {Vector2D} endpoint - end point of arc
       * @param {Object} [options] - options for construction
       * @param {Number} [options.radius=0] - radius of arc (X and Y), see also xradius and yradius
       * @param {Number} [options.xradius=0] - X radius of arc, see also radius
       * @param {Number} [options.yradius=0] - Y radius of arc, see also radius
       * @param {Number} [options.xaxisrotation=0] -  rotation (in degrees) of the X axis of the arc with respect to the X axis of the coordinate system
       * @param {Number} [options.resolution=defaultResolution2D] - number of sides per 360 rotation
       * @param {Boolean} [options.clockwise=false] - draw an arc clockwise with respect to the center point
       * @param {Boolean} [options.large=false] - draw an arc longer than 180 degrees
       * @returns {Path2D} new Path2D object (not closed)
       *
       * @example
       * let p1 = new CSG.Path2D([[27.5,-22.96875]],false);
       * p1 = p1.appendPoint([27.5,-3.28125]);
       * p1 = p1.appendArc([12.5,-22.96875],{xradius: 15,yradius: -19.6875,xaxisrotation: 0,clockwise: false,large: false});
       * p1 = p1.close();
       */
      appendArc: function(endpoint, options) {
        let decimals = 1e5;
        if (arguments.length < 2) {
          options = {};
        }
        if (this.closed) {
          throw new Error("Path must not be closed");
        }
        if (this.points.length < 1) {
          throw new Error("appendArc: path must already contain a point (the endpoint of the path is used as the starting point for the arc)");
        }
        let resolution = parseOptionAsInt(options, "resolution", defaultResolution2D);
        if (resolution < 4) resolution = 4;
        let xradius, yradius;
        if ("xradius" in options || "yradius" in options) {
          if ("radius" in options) {
            throw new Error("Should either give an xradius and yradius parameter, or a radius parameter");
          }
          xradius = parseOptionAsFloat(options, "xradius", 0);
          yradius = parseOptionAsFloat(options, "yradius", 0);
        } else {
          xradius = parseOptionAsFloat(options, "radius", 0);
          yradius = xradius;
        }
        let xaxisrotation = parseOptionAsFloat(options, "xaxisrotation", 0);
        let clockwise = parseOptionAsBool(options, "clockwise", false);
        let largearc = parseOptionAsBool(options, "large", false);
        let startpoint = this.points[this.points.length - 1];
        endpoint = new Vector2D(endpoint);
        xradius = Math.round(xradius * decimals) / decimals;
        yradius = Math.round(yradius * decimals) / decimals;
        endpoint = new Vector2D(Math.round(endpoint.x * decimals) / decimals, Math.round(endpoint.y * decimals) / decimals);
        let sweepFlag = !clockwise;
        let newpoints = [];
        if (xradius === 0 || yradius === 0) {
          newpoints.push(endpoint);
        } else {
          xradius = Math.abs(xradius);
          yradius = Math.abs(yradius);
          let phi = xaxisrotation * Math.PI / 180;
          let cosphi = Math.cos(phi);
          let sinphi = Math.sin(phi);
          let minushalfdistance = startpoint.minus(endpoint).times(0.5);
          let x = Math.round((cosphi * minushalfdistance.x + sinphi * minushalfdistance.y) * decimals) / decimals;
          let y = Math.round((-sinphi * minushalfdistance.x + cosphi * minushalfdistance.y) * decimals) / decimals;
          let startTranslated = new Vector2D(x, y);
          let biglambda = startTranslated.x * startTranslated.x / (xradius * xradius) + startTranslated.y * startTranslated.y / (yradius * yradius);
          if (biglambda > 1) {
            let sqrtbiglambda = Math.sqrt(biglambda);
            xradius *= sqrtbiglambda;
            yradius *= sqrtbiglambda;
            xradius = Math.round(xradius * decimals) / decimals;
            yradius = Math.round(yradius * decimals) / decimals;
          }
          let multiplier1 = Math.sqrt((xradius * xradius * yradius * yradius - xradius * xradius * startTranslated.y * startTranslated.y - yradius * yradius * startTranslated.x * startTranslated.x) / (xradius * xradius * startTranslated.y * startTranslated.y + yradius * yradius * startTranslated.x * startTranslated.x));
          if (sweepFlag === largearc) multiplier1 = -multiplier1;
          let centerTranslated = new Vector2D(xradius * startTranslated.y / yradius, -yradius * startTranslated.x / xradius).times(multiplier1);
          let center = new Vector2D(cosphi * centerTranslated.x - sinphi * centerTranslated.y, sinphi * centerTranslated.x + cosphi * centerTranslated.y).plus(startpoint.plus(endpoint).times(0.5));
          let vec1 = new Vector2D((startTranslated.x - centerTranslated.x) / xradius, (startTranslated.y - centerTranslated.y) / yradius);
          let vec2 = new Vector2D((-startTranslated.x - centerTranslated.x) / xradius, (-startTranslated.y - centerTranslated.y) / yradius);
          let theta1 = vec1.angleRadians();
          let theta2 = vec2.angleRadians();
          let deltatheta = theta2 - theta1;
          deltatheta = deltatheta % (2 * Math.PI);
          if (!sweepFlag && deltatheta > 0) {
            deltatheta -= 2 * Math.PI;
          } else if (sweepFlag && deltatheta < 0) {
            deltatheta += 2 * Math.PI;
          }
          let numsteps = Math.ceil(Math.abs(deltatheta) / (2 * Math.PI) * resolution) + 1;
          if (numsteps < 1) numsteps = 1;
          for (let step = 1; step <= numsteps; step++) {
            let theta = theta1 + step / numsteps * deltatheta;
            let costheta = Math.cos(theta);
            let sintheta = Math.sin(theta);
            let point = new Vector2D(cosphi * xradius * costheta - sinphi * yradius * sintheta, sinphi * xradius * costheta + cosphi * yradius * sintheta).plus(center);
            newpoints.push(point);
          }
        }
        newpoints = this.points.concat(newpoints);
        let result = new Path2D(newpoints);
        return result;
      }
    };
    module.exports = Path2D;
  }
});

// src/core/vendor/csg/src/api/helpers.js
var require_helpers = __commonJS({
  "src/core/vendor/csg/src/api/helpers.js"(exports, module) {
    "use strict";
    var Vertex3 = require_Vertex3();
    var Vector3 = require_Vector3();
    var Polygon3 = require_Polygon3();
    var polygonFromPoints = (points) => {
      const vertices = points.map((point) => new Vertex3(new Vector3(point)));
      return new Polygon3(vertices);
    };
    var rightMultiply1x3VectorToArray = (matrix, vector) => {
      const [v0, v1, v2] = vector;
      const v3 = 1;
      let x = v0 * matrix.elements[0] + v1 * matrix.elements[1] + v2 * matrix.elements[2] + v3 * matrix.elements[3];
      let y = v0 * matrix.elements[4] + v1 * matrix.elements[5] + v2 * matrix.elements[6] + v3 * matrix.elements[7];
      let z = v0 * matrix.elements[8] + v1 * matrix.elements[9] + v2 * matrix.elements[10] + v3 * matrix.elements[11];
      let w = v0 * matrix.elements[12] + v1 * matrix.elements[13] + v2 * matrix.elements[14] + v3 * matrix.elements[15];
      if (w !== 1) {
        const invw = 1 / w;
        x *= invw;
        y *= invw;
        z *= invw;
      }
      return [x, y, z];
    };
    function clamp(value, min, max) {
      return Math.min(Math.max(value, min), max);
    }
    var cagToPointsArray = (input) => {
      let points;
      if ("sides" in input) {
        points = [];
        input.sides.forEach((side) => {
          points.push([side.vertex0.pos.x, side.vertex0.pos.y]);
          points.push([side.vertex1.pos.x, side.vertex1.pos.y]);
        });
      } else if ("points" in input) {
        points = input.points.map((p) => [p.x, p.y]);
      }
      return points;
    };
    module.exports = { cagToPointsArray, clamp, rightMultiply1x3VectorToArray, polygonFromPoints };
  }
});

// src/core/vendor/csg/src/api/ops-extrusions.js
var require_ops_extrusions = __commonJS({
  "src/core/vendor/csg/src/api/ops-extrusions.js"(exports, module) {
    "use strict";
    var { EPS, defaultResolution3D } = require_constants();
    var OrthoNormalBasis = require_OrthoNormalBasis();
    var { parseOptionAs3DVector, parseOptionAsBool, parseOptionAsFloat, parseOptionAsInt } = require_optionParsers();
    var Vector3D = require_Vector3();
    var Matrix4 = require_Matrix4();
    var Path2D = require_Path2();
    var { Connector } = require_connectors();
    var { fromPolygons } = require_CSGFactories();
    var { cagToPointsArray, clamp, rightMultiply1x3VectorToArray, polygonFromPoints } = require_helpers();
    var { fromPoints } = require_CAGFactories();
    var extrudeInOrthonormalBasis = function(cag, orthonormalbasis, depth, options) {
      if (!(orthonormalbasis instanceof OrthoNormalBasis)) {
        throw new Error("extrudeInPlane: the first parameter should be a OrthoNormalBasis");
      }
      let extruded = cag.extrude({
        offset: [0, 0, depth]
      });
      if (parseOptionAsBool(options, "symmetrical", false)) {
        extruded = extruded.translate([0, 0, -depth / 2]);
      }
      let matrix = orthonormalbasis.getInverseProjectionMatrix();
      extruded = extruded.transform(matrix);
      return extruded;
    };
    var extrudeInPlane = function(cag, axis1, axis2, depth, options) {
      return extrudeInOrthonormalBasis(cag, OrthoNormalBasis.GetCartesian(axis1, axis2), depth, options);
    };
    var extrude = function(cag, options) {
      const CSG = require_CSG();
      if (cag.sides.length === 0) {
        return new CSG();
      }
      let offsetVector = parseOptionAs3DVector(options, "offset", [0, 0, 1]);
      let twistangle = parseOptionAsFloat(options, "twistangle", 0);
      let twiststeps = parseOptionAsInt(options, "twiststeps", defaultResolution3D);
      if (offsetVector.z === 0) {
        throw new Error("offset cannot be orthogonal to Z axis");
      }
      if (twistangle === 0 || twiststeps < 1) {
        twiststeps = 1;
      }
      let normalVector = Vector3D.Create(0, 1, 0);
      let polygons = [];
      polygons = polygons.concat(cag._toPlanePolygons(
        {
          translation: [0, 0, 0],
          normalVector,
          flipped: !(offsetVector.z < 0)
        }
      ));
      polygons = polygons.concat(cag._toPlanePolygons({
        translation: offsetVector,
        normalVector: normalVector.rotateZ(twistangle),
        flipped: offsetVector.z < 0
      }));
      for (let i = 0; i < twiststeps; i++) {
        let c1 = new Connector(
          offsetVector.times(i / twiststeps),
          [0, 0, offsetVector.z],
          normalVector.rotateZ(i * twistangle / twiststeps)
        );
        let c2 = new Connector(
          offsetVector.times((i + 1) / twiststeps),
          [0, 0, offsetVector.z],
          normalVector.rotateZ((i + 1) * twistangle / twiststeps)
        );
        polygons = polygons.concat(cag._toWallPolygons({ toConnector1: c1, toConnector2: c2 }));
      }
      return fromPolygons(polygons);
    };
    var rotateExtrude = function(cag, options) {
      let alpha = parseOptionAsFloat(options, "angle", 360);
      let resolution = parseOptionAsInt(options, "resolution", defaultResolution3D);
      alpha = alpha > 360 ? alpha % 360 : alpha;
      let origin = [0, 0, 0];
      let axisV = Vector3D.Create(0, 1, 0);
      let normalV = [0, 0, 1];
      let polygons = [];
      let connS = new Connector(origin, axisV, normalV);
      if (alpha > 0 && alpha < 360) {
        let connE = new Connector(origin, axisV.rotateZ(-alpha), normalV);
        polygons = polygons.concat(
          cag._toPlanePolygons({ toConnector: connS, flipped: true })
        );
        polygons = polygons.concat(
          cag._toPlanePolygons({ toConnector: connE })
        );
      }
      let connT1 = connS;
      let connT2;
      let step = alpha / resolution;
      for (let a = step; a <= alpha + EPS; a += step) {
        connT2 = new Connector(origin, axisV.rotateZ(-a), normalV);
        polygons = polygons.concat(cag._toWallPolygons(
          { toConnector1: connT1, toConnector2: connT2 }
        ));
        connT1 = connT2;
      }
      return fromPolygons(polygons).reTesselated();
    };
    function linear_extrude(params, baseShape) {
      const defaults = {
        height: 1,
        slices: 10,
        twist: 0,
        center: false
      };
      const { height, twist, slices, center } = Object.assign({}, defaults, params);
      let output = baseShape.extrude({ offset: [0, 0, height], twistangle: twist, twiststeps: slices });
      if (center === true) {
        const b = output.getBounds();
        const offset = b[1].plus(b[0]).times(-0.5);
        output = output.translate(offset);
      }
      return output;
    }
    function rotate_extrude(params, baseShape) {
      const defaults = {
        fn: 32,
        startAngle: 0,
        angle: 360,
        overflow: "cap"
      };
      params = Object.assign({}, defaults, params);
      let { fn, startAngle, angle, overflow } = params;
      if (overflow !== "cap") {
        throw new Error("only capping of overflowing points is supported !");
      }
      if (arguments.length < 2) {
        baseShape = params;
      }
      const flipped = angle > 0;
      const totalAngle = flipped ? clamp(startAngle + angle, 0, 360) : clamp(startAngle + angle, -360, 0);
      const segments = Math.max(
        Math.floor(Math.abs(totalAngle) / 45),
        1,
        fn
      );
      const overlapTolerance = 1e-5;
      let shapePoints = cagToPointsArray(baseShape);
      const pointsWithNegativeX = shapePoints.filter((x) => x[0] < 0);
      const pointsWithPositiveX = shapePoints.filter((x) => x[0] >= 0);
      const arePointsWithNegAndPosX = pointsWithNegativeX.length > 0 && pointsWithPositiveX.length > 0;
      if (arePointsWithNegAndPosX && overflow === "cap") {
        if (pointsWithNegativeX.length > pointsWithPositiveX.length) {
          shapePoints = shapePoints.map(function(point) {
            return [Math.min(point[0], 0), point[1]];
          });
        } else if (pointsWithPositiveX.length >= pointsWithNegativeX.length) {
          shapePoints = shapePoints.map(function(point) {
            return [Math.max(point[0], 0), point[1]];
          });
        }
      }
      let polygons = [];
      for (let i = 1; i < segments + 1; i++) {
        for (let j = 0; j < shapePoints.length - 1; j++) {
          const curPoint = shapePoints[j];
          const nextPoint = shapePoints[j + 1];
          let prevMatrix = Matrix4.rotationZ((i - 1) / segments * angle + startAngle);
          let curMatrix = Matrix4.rotationZ(i / segments * angle + startAngle);
          const pointA = rightMultiply1x3VectorToArray(prevMatrix, [curPoint[0], 0, curPoint[1]]);
          const pointAP = rightMultiply1x3VectorToArray(curMatrix, [curPoint[0], 0, curPoint[1]]);
          const pointB = rightMultiply1x3VectorToArray(prevMatrix, [nextPoint[0], 0, nextPoint[1]]);
          const pointBP = rightMultiply1x3VectorToArray(curMatrix, [nextPoint[0], 0, nextPoint[1]]);
          let overlappingPoints = false;
          if (Math.abs(pointA[0] - pointAP[0]) < overlapTolerance && Math.abs(pointB[1] - pointBP[1]) < overlapTolerance) {
            overlappingPoints = true;
          }
          if (flipped) {
            polygons.push(polygonFromPoints([pointA, pointB, pointBP]));
            if (!overlappingPoints) {
              polygons.push(polygonFromPoints([pointBP, pointAP, pointA]));
            }
          } else {
            if (!overlappingPoints) {
              polygons.push(polygonFromPoints([pointA, pointAP, pointBP]));
            }
            polygons.push(polygonFromPoints([pointBP, pointB, pointA]));
          }
        }
        if (Math.abs(angle) < 360) {
          const sideShape = fromPoints(shapePoints);
          const endMatrix = Matrix4.rotationX(90).multiply(
            Matrix4.rotationZ(-startAngle)
          );
          const endCap = sideShape._toPlanePolygons({ flipped }).map((x) => x.transform(endMatrix));
          const startMatrix = Matrix4.rotationX(90).multiply(
            Matrix4.rotationZ(-angle - startAngle)
          );
          const startCap = sideShape._toPlanePolygons({ flipped: !flipped }).map((x) => x.transform(startMatrix));
          polygons = polygons.concat(endCap).concat(startCap);
        }
      }
      return fromPolygons(polygons).reTesselated().canonicalized();
    }
    function rectangular_extrude(basePoints, params) {
      const defaults = {
        w: 1,
        h: 1,
        fn: 8,
        closed: false,
        round: true
      };
      const { w, h, fn, closed, round } = Object.assign({}, defaults, params);
      return new Path2D(basePoints, closed).rectangularExtrude(w, h, fn, round);
    }
    module.exports = {
      extrudeInOrthonormalBasis,
      extrudeInPlane,
      extrude,
      linear_extrude,
      rotate_extrude,
      rotateExtrude,
      rectangular_extrude
    };
  }
});

// src/core/vendor/csg/src/api/cagOutlinePaths.js
var require_cagOutlinePaths = __commonJS({
  "src/core/vendor/csg/src/api/cagOutlinePaths.js"(exports, module) {
    "use strict";
    var Path2D = require_Path2();
    var cagoutlinePaths = function(_cag) {
      let cag = _cag.canonicalized();
      let sideTagToSideMap = {};
      let startVertexTagToSideTagMap = {};
      cag.sides.map(function(side) {
        let sidetag = side.getTag();
        sideTagToSideMap[sidetag] = side;
        let startvertextag = side.vertex0.getTag();
        if (!(startvertextag in startVertexTagToSideTagMap)) {
          startVertexTagToSideTagMap[startvertextag] = [];
        }
        startVertexTagToSideTagMap[startvertextag].push(sidetag);
      });
      let paths = [];
      while (true) {
        let startsidetag = null;
        for (let aVertexTag in startVertexTagToSideTagMap) {
          let sidesForcagVertex = startVertexTagToSideTagMap[aVertexTag];
          startsidetag = sidesForcagVertex[0];
          sidesForcagVertex.splice(0, 1);
          if (sidesForcagVertex.length === 0) {
            delete startVertexTagToSideTagMap[aVertexTag];
          }
          break;
        }
        if (startsidetag === null) break;
        let connectedVertexPoints = [];
        let sidetag = startsidetag;
        let cagside = sideTagToSideMap[sidetag];
        let startvertextag = cagside.vertex0.getTag();
        while (true) {
          connectedVertexPoints.push(cagside.vertex0.pos);
          let nextvertextag = cagside.vertex1.getTag();
          if (nextvertextag === startvertextag) break;
          if (!(nextvertextag in startVertexTagToSideTagMap)) {
            throw new Error("Area is not closed!");
          }
          let nextpossiblesidetags = startVertexTagToSideTagMap[nextvertextag];
          let nextsideindex = -1;
          if (nextpossiblesidetags.length === 1) {
            nextsideindex = 0;
          } else {
            let bestangle = null;
            let cagangle = cagside.direction().angleDegrees();
            for (let sideindex = 0; sideindex < nextpossiblesidetags.length; sideindex++) {
              let nextpossiblesidetag = nextpossiblesidetags[sideindex];
              let possibleside = sideTagToSideMap[nextpossiblesidetag];
              let angle = possibleside.direction().angleDegrees();
              let angledif = angle - cagangle;
              if (angledif < -180) angledif += 360;
              if (angledif >= 180) angledif -= 360;
              if (nextsideindex < 0 || angledif > bestangle) {
                nextsideindex = sideindex;
                bestangle = angledif;
              }
            }
          }
          let nextsidetag = nextpossiblesidetags[nextsideindex];
          nextpossiblesidetags.splice(nextsideindex, 1);
          if (nextpossiblesidetags.length === 0) {
            delete startVertexTagToSideTagMap[nextvertextag];
          }
          cagside = sideTagToSideMap[nextsidetag];
        }
        if (connectedVertexPoints.length > 0) {
          connectedVertexPoints.push(connectedVertexPoints.shift());
        }
        let path = new Path2D(connectedVertexPoints, true);
        paths.push(path);
      }
      return paths;
    };
    module.exports = cagoutlinePaths;
  }
});

// src/core/vendor/csg/src/core/utils/toArray.js
var require_toArray = __commonJS({
  "src/core/vendor/csg/src/core/utils/toArray.js"(exports, module) {
    "use strict";
    function toArray(data) {
      if (!data) return [];
      if (data.constructor !== Array) return [data];
      return data;
    }
    module.exports = toArray;
  }
});

// src/core/vendor/csg/src/api/center.js
var require_center = __commonJS({
  "src/core/vendor/csg/src/api/center.js"(exports, module) {
    "use strict";
    var toArray = require_toArray();
    var center = function(options, objects) {
      const defaults = {
        axes: [true, true, true],
        center: [0, 0, 0]
        // TODO : Add addition 'methods' of centering; midpoint, centeriod
      };
      options = Object.assign({}, defaults, options);
      const { axes, center: center2 } = options;
      objects = toArray(objects);
      const results = objects.map(function(object) {
        let bounds = object.getBounds();
        let offset = [0, 0, 0];
        if (axes[0]) offset[0] = center2[0] - (bounds[0].x + (bounds[1].x - bounds[0].x) / 2);
        if (axes[1]) offset[1] = center2[1] - (bounds[0].y + (bounds[1].y - bounds[0].y) / 2);
        if (axes[2]) offset[2] = center2[2] - (bounds[0].z + (bounds[1].y - bounds[0].y) / 2);
        return object.translate(offset);
      });
      return results.length === 1 ? results[0] : results;
    };
    module.exports = center;
  }
});

// src/core/vendor/csg/src/api/ops-expandContract.js
var require_ops_expandContract = __commonJS({
  "src/core/vendor/csg/src/api/ops-expandContract.js"(exports, module) {
    "use strict";
    var { EPS, angleEPS } = require_constants();
    var Vertex = require_Vertex3();
    var Vector2D = require_Vector2();
    var Polygon = require_Polygon3();
    var { fnNumberSort, isCSG } = require_utils();
    var { fromPoints, fromPointsNoCheck } = require_CAGFactories();
    var expand = function(shape, radius, resolution) {
      let result;
      if (isCSG(shape)) {
        result = shape.union(expandedShellOfCCSG(shape, radius, resolution));
        result = result.reTesselated();
        result.properties = shape.properties;
      } else {
        result = shape.union(expandedShellOfCAG(shape, radius, resolution));
      }
      return result;
    };
    var contract = function(shape, radius, resolution) {
      let result;
      if (isCSG(shape)) {
        result = shape.subtract(expandedShellOfCCSG(shape, radius, resolution));
        result = result.reTesselated();
        result.properties = shape.properties;
      } else {
        result = shape.subtract(expandedShellOfCAG(shape, radius, resolution));
      }
      return result;
    };
    var expandedShellOfCAG = function(_cag, radius, resolution) {
      const CAG = require_CAG();
      resolution = resolution || 8;
      if (resolution < 4) resolution = 4;
      let cags = [];
      let pointmap = {};
      let cag = _cag.canonicalized();
      cag.sides.map(function(side) {
        let d = side.vertex1.pos.minus(side.vertex0.pos);
        let dl = d.length();
        if (dl > EPS) {
          d = d.times(1 / dl);
          let normal = d.normal().times(radius);
          let shellpoints = [
            side.vertex1.pos.plus(normal),
            side.vertex1.pos.minus(normal),
            side.vertex0.pos.minus(normal),
            side.vertex0.pos.plus(normal)
          ];
          let newcag = fromPoints(shellpoints);
          cags.push(newcag);
          for (let step = 0; step < 2; step++) {
            let p1 = step === 0 ? side.vertex0.pos : side.vertex1.pos;
            let p2 = step === 0 ? side.vertex1.pos : side.vertex0.pos;
            let tag = p1.x + " " + p1.y;
            if (!(tag in pointmap)) {
              pointmap[tag] = [];
            }
            pointmap[tag].push({
              "p1": p1,
              "p2": p2
            });
          }
        }
      });
      for (let tag in pointmap) {
        let m = pointmap[tag];
        let angle1, angle2;
        let pcenter = m[0].p1;
        if (m.length === 2) {
          let end1 = m[0].p2;
          let end2 = m[1].p2;
          angle1 = end1.minus(pcenter).angleDegrees();
          angle2 = end2.minus(pcenter).angleDegrees();
          if (angle2 < angle1) angle2 += 360;
          if (angle2 >= angle1 + 360) angle2 -= 360;
          if (angle2 < angle1 + 180) {
            let t = angle2;
            angle2 = angle1 + 360;
            angle1 = t;
          }
          angle1 += 90;
          angle2 -= 90;
        } else {
          angle1 = 0;
          angle2 = 360;
        }
        let fullcircle = angle2 > angle1 + 359.999;
        if (fullcircle) {
          angle1 = 0;
          angle2 = 360;
        }
        if (angle2 > angle1 + angleEPS) {
          let points = [];
          if (!fullcircle) {
            points.push(pcenter);
          }
          let numsteps = Math.round(resolution * (angle2 - angle1) / 360);
          if (numsteps < 1) numsteps = 1;
          for (let step = 0; step <= numsteps; step++) {
            let angle = angle1 + step / numsteps * (angle2 - angle1);
            if (step === numsteps) angle = angle2;
            let point = pcenter.plus(Vector2D.fromAngleDegrees(angle).times(radius));
            if (!fullcircle || step > 0) {
              points.push(point);
            }
          }
          let newcag = fromPointsNoCheck(points);
          cags.push(newcag);
        }
      }
      let result = new CAG();
      result = result.union(cags);
      return result;
    };
    var expandedShellOfCCSG = function(_csg, radius, resolution, unionWithThis) {
      const CSG = require_CSG();
      const { fromPolygons } = require_CSGFactories();
      let csg = _csg.reTesselated();
      let result;
      if (unionWithThis) {
        result = csg;
      } else {
        result = new CSG();
      }
      csg.polygons.map(function(polygon) {
        let extrudevector = polygon.plane.normal.unit().times(2 * radius);
        let translatedpolygon = polygon.translate(extrudevector.times(-0.5));
        let extrudedface = translatedpolygon.extrude(extrudevector);
        result = result.unionSub(extrudedface, false, false);
      });
      let vertexpairs = {};
      csg.polygons.map(function(polygon) {
        let numvertices = polygon.vertices.length;
        let prevvertex = polygon.vertices[numvertices - 1];
        let prevvertextag = prevvertex.getTag();
        for (let i = 0; i < numvertices; i++) {
          let vertex = polygon.vertices[i];
          let vertextag = vertex.getTag();
          let vertextagpair;
          if (vertextag < prevvertextag) {
            vertextagpair = vertextag + "-" + prevvertextag;
          } else {
            vertextagpair = prevvertextag + "-" + vertextag;
          }
          let obj;
          if (vertextagpair in vertexpairs) {
            obj = vertexpairs[vertextagpair];
          } else {
            obj = {
              v1: prevvertex,
              v2: vertex,
              planenormals: []
            };
            vertexpairs[vertextagpair] = obj;
          }
          obj.planenormals.push(polygon.plane.normal);
          prevvertextag = vertextag;
          prevvertex = vertex;
        }
      });
      for (let vertextagpair in vertexpairs) {
        let vertexpair = vertexpairs[vertextagpair];
        let startpoint = vertexpair.v1.pos;
        let endpoint = vertexpair.v2.pos;
        let zbase = endpoint.minus(startpoint).unit();
        let xbase = vertexpair.planenormals[0].unit();
        let ybase = xbase.cross(zbase);
        let angles = [];
        for (let i = 0; i < resolution; i++) {
          angles.push(i * Math.PI * 2 / resolution);
        }
        for (let i = 0, iMax = vertexpair.planenormals.length; i < iMax; i++) {
          let planenormal = vertexpair.planenormals[i];
          let si = ybase.dot(planenormal);
          let co = xbase.dot(planenormal);
          let angle = Math.atan2(si, co);
          if (angle < 0) angle += Math.PI * 2;
          angles.push(angle);
          angle = Math.atan2(-si, -co);
          if (angle < 0) angle += Math.PI * 2;
          angles.push(angle);
        }
        angles = angles.sort(fnNumberSort);
        let numangles = angles.length;
        let prevp1;
        let prevp2;
        let startfacevertices = [];
        let endfacevertices = [];
        let polygons = [];
        for (let i = -1; i < numangles; i++) {
          let angle = angles[i < 0 ? i + numangles : i];
          let si = Math.sin(angle);
          let co = Math.cos(angle);
          let p = xbase.times(co * radius).plus(ybase.times(si * radius));
          let p1 = startpoint.plus(p);
          let p2 = endpoint.plus(p);
          let skip = false;
          if (i >= 0) {
            if (p1.distanceTo(prevp1) < EPS) {
              skip = true;
            }
          }
          if (!skip) {
            if (i >= 0) {
              startfacevertices.push(new Vertex(p1));
              endfacevertices.push(new Vertex(p2));
              let polygonvertices = [
                new Vertex(prevp2),
                new Vertex(p2),
                new Vertex(p1),
                new Vertex(prevp1)
              ];
              let polygon = new Polygon(polygonvertices);
              polygons.push(polygon);
            }
            prevp1 = p1;
            prevp2 = p2;
          }
        }
        endfacevertices.reverse();
        polygons.push(new Polygon(startfacevertices));
        polygons.push(new Polygon(endfacevertices));
        let cylinder = fromPolygons(polygons);
        result = result.unionSub(cylinder, false, false);
      }
      let vertexmap = {};
      csg.polygons.map(function(polygon) {
        polygon.vertices.map(function(vertex) {
          let vertextag = vertex.getTag();
          let obj;
          if (vertextag in vertexmap) {
            obj = vertexmap[vertextag];
          } else {
            obj = {
              pos: vertex.pos,
              normals: []
            };
            vertexmap[vertextag] = obj;
          }
          obj.normals.push(polygon.plane.normal);
        });
      });
      for (let vertextag in vertexmap) {
        let vertexobj = vertexmap[vertextag];
        let xaxis = vertexobj.normals[0].unit();
        let bestzaxis = null;
        let bestzaxisorthogonality = 0;
        for (let i = 1; i < vertexobj.normals.length; i++) {
          let normal = vertexobj.normals[i].unit();
          let cross = xaxis.cross(normal);
          let crosslength = cross.length();
          if (crosslength > 0.05) {
            if (crosslength > bestzaxisorthogonality) {
              bestzaxisorthogonality = crosslength;
              bestzaxis = normal;
            }
          }
        }
        if (!bestzaxis) {
          bestzaxis = xaxis.randomNonParallelVector();
        }
        let yaxis = xaxis.cross(bestzaxis).unit();
        let zaxis = yaxis.cross(xaxis);
        let _sphere = CSG.sphere({
          center: vertexobj.pos,
          radius,
          resolution,
          axes: [xaxis, yaxis, zaxis]
        });
        result = result.unionSub(_sphere, false, false);
      }
      return result;
    };
    module.exports = {
      expand,
      contract,
      expandedShellOfCAG,
      expandedShellOfCCSG
    };
  }
});

// src/core/vendor/csg/src/core/CAG.js
var require_CAG = __commonJS({
  "src/core/vendor/csg/src/core/CAG.js"(exports, module) {
    "use strict";
    var { Connector } = require_connectors();
    var Vertex3D = require_Vertex3();
    var Vector2D = require_Vector2();
    var Vector3D = require_Vector3();
    var Polygon = require_Polygon3();
    var { fromPolygons } = require_CSGFactories();
    var { fromSides, fromFakeCSG } = require_CAGFactories();
    var canonicalize = require_canonicalize();
    var retesselate = require_retesellate();
    var { isCAGValid, isSelfIntersecting, hasPointInside } = require_cagValidation();
    var { area, getBounds } = require_cagMeasurements();
    var { overCutInsideCorners } = require_ops_cnc();
    var { extrudeInOrthonormalBasis, extrudeInPlane, extrude, rotateExtrude } = require_ops_extrusions();
    var cagoutlinePaths = require_cagOutlinePaths();
    var center = require_center();
    var { expand, contract, expandedShellOfCAG } = require_ops_expandContract();
    var CAG = function() {
      this.sides = [];
      this.isCanonicalized = false;
    };
    CAG.prototype = {
      union: function(cag) {
        let cags;
        if (cag instanceof Array) {
          cags = cag;
        } else {
          cags = [cag];
        }
        let r = this._toCSGWall(-1, 1);
        r = r.union(
          cags.map(function(cag2) {
            return cag2._toCSGWall(-1, 1).reTesselated();
          }),
          false,
          false
        );
        return fromFakeCSG(r).canonicalized();
      },
      subtract: function(cag) {
        let cags;
        if (cag instanceof Array) {
          cags = cag;
        } else {
          cags = [cag];
        }
        let r = this._toCSGWall(-1, 1);
        cags.map(function(cag2) {
          r = r.subtractSub(cag2._toCSGWall(-1, 1), false, false);
        });
        r = r.reTesselated();
        r = r.canonicalized();
        r = fromFakeCSG(r);
        r = r.canonicalized();
        return r;
      },
      intersect: function(cag) {
        let cags;
        if (cag instanceof Array) {
          cags = cag;
        } else {
          cags = [cag];
        }
        let r = this._toCSGWall(-1, 1);
        cags.map(function(cag2) {
          r = r.intersectSub(cag2._toCSGWall(-1, 1), false, false);
        });
        r = r.reTesselated();
        r = r.canonicalized();
        r = fromFakeCSG(r);
        r = r.canonicalized();
        return r;
      },
      transform: function(matrix4x4) {
        let ismirror = matrix4x4.isMirroring();
        let newsides = this.sides.map(function(side) {
          return side.transform(matrix4x4);
        });
        let result = fromSides(newsides);
        if (ismirror) {
          result = result.flipped();
        }
        return result;
      },
      flipped: function() {
        let newsides = this.sides.map(function(side) {
          return side.flipped();
        });
        newsides.reverse();
        return fromSides(newsides);
      },
      // ALIAS !
      center: function(axes) {
        return center({ axes }, [this]);
      },
      // ALIAS !
      expandedShell: function(radius, resolution) {
        return expandedShellOfCAG(this, radius, resolution);
      },
      // ALIAS !
      expand: function(radius, resolution) {
        return expand(this, radius, resolution);
      },
      contract: function(radius, resolution) {
        return contract(this, radius, resolution);
      },
      // ALIAS !
      area: function() {
        return area(this);
      },
      // ALIAS !
      getBounds: function() {
        return getBounds(this);
      },
      // ALIAS !
      isSelfIntersecting: function(debug) {
        return isSelfIntersecting(this, debug);
      },
      // extrusion: all aliases to simple functions
      extrudeInOrthonormalBasis: function(orthonormalbasis, depth, options) {
        return extrudeInOrthonormalBasis(this, orthonormalbasis, depth, options);
      },
      // ALIAS !
      extrudeInPlane: function(axis1, axis2, depth, options) {
        return extrudeInPlane(this, axis1, axis2, depth, options);
      },
      // ALIAS !
      extrude: function(options) {
        return extrude(this, options);
      },
      // ALIAS !
      rotateExtrude: function(options) {
        return rotateExtrude(this, options);
      },
      // ALIAS !
      check: function() {
        return isCAGValid(this);
      },
      // ALIAS !
      canonicalized: function() {
        return canonicalize(this);
      },
      // ALIAS !
      reTesselated: function() {
        return retesselate(this);
      },
      // ALIAS !
      getOutlinePaths: function() {
        return cagoutlinePaths(this);
      },
      // ALIAS !
      overCutInsideCorners: function(cutterradius) {
        return overCutInsideCorners(this, cutterradius);
      },
      // ALIAS !
      hasPointInside: function(point) {
        return hasPointInside(this, point);
      },
      // All the toXXX functions
      toString: function() {
        let result = "CAG (" + this.sides.length + " sides):\n";
        this.sides.map(function(side) {
          result += "  " + side.toString() + "\n";
        });
        return result;
      },
      _toCSGWall: function(z0, z1) {
        let polygons = this.sides.map(function(side) {
          return side.toPolygon3D(z0, z1);
        });
        return fromPolygons(polygons);
      },
      _toVector3DPairs: function(m) {
        let pairs = this.sides.map(function(side) {
          let p0 = side.vertex0.pos;
          let p1 = side.vertex1.pos;
          return [
            Vector3D.Create(p0.x, p0.y, 0),
            Vector3D.Create(p1.x, p1.y, 0)
          ];
        });
        if (typeof m !== "undefined") {
          pairs = pairs.map(function(pair) {
            return pair.map(function(v) {
              return v.transform(m);
            });
          });
        }
        return pairs;
      },
      /*
        * transform a cag into the polygons of a corresponding 3d plane, positioned per options
        * Accepts a connector for plane positioning, or optionally
        * single translation, axisVector, normalVector arguments
        * (toConnector has precedence over single arguments if provided)
        */
      _toPlanePolygons: function(options) {
        const defaults = {
          flipped: false
        };
        options = Object.assign({}, defaults, options);
        let { flipped } = options;
        let origin = [0, 0, 0];
        let defaultAxis = [0, 0, 1];
        let defaultNormal = [0, 1, 0];
        let thisConnector = new Connector(origin, defaultAxis, defaultNormal);
        let translation = options.translation || origin;
        let axisVector = options.axisVector || defaultAxis;
        let normalVector = options.normalVector || defaultNormal;
        let toConnector = options.toConnector || new Connector(translation, axisVector, normalVector);
        let m = thisConnector.getTransformationTo(toConnector, false, 0);
        let bounds = this.getBounds();
        bounds[0] = bounds[0].minus(new Vector2D(1, 1));
        bounds[1] = bounds[1].plus(new Vector2D(1, 1));
        let csgshell = this._toCSGWall(-1, 1);
        let csgplane = fromPolygons([new Polygon([
          new Vertex3D(new Vector3D(bounds[0].x, bounds[0].y, 0)),
          new Vertex3D(new Vector3D(bounds[1].x, bounds[0].y, 0)),
          new Vertex3D(new Vector3D(bounds[1].x, bounds[1].y, 0)),
          new Vertex3D(new Vector3D(bounds[0].x, bounds[1].y, 0))
        ])]);
        if (flipped) {
          csgplane = csgplane.invert();
        }
        csgplane = csgplane.intersectSub(csgshell);
        let polys = csgplane.polygons.filter(function(polygon) {
          return Math.abs(polygon.plane.normal.z) > 0.99;
        });
        return polys.map(function(poly) {
          return poly.transform(m);
        });
      },
      /*
        * given 2 connectors, this returns all polygons of a "wall" between 2
        * copies of this cag, positioned in 3d space as "bottom" and
        * "top" plane per connectors toConnector1, and toConnector2, respectively
        */
      _toWallPolygons: function(options) {
        let origin = [0, 0, 0];
        let defaultAxis = [0, 0, 1];
        let defaultNormal = [0, 1, 0];
        let thisConnector = new Connector(origin, defaultAxis, defaultNormal);
        let toConnector1 = options.toConnector1;
        let toConnector2 = options.toConnector2;
        if (!(toConnector1 instanceof Connector && toConnector2 instanceof Connector)) {
          throw new Error("could not parse Connector arguments toConnector1 or toConnector2");
        }
        if (options.cag) {
          if (options.cag.sides.length !== this.sides.length) {
            throw new Error("target cag needs same sides count as start cag");
          }
        }
        let toCag = options.cag || this;
        let m1 = thisConnector.getTransformationTo(toConnector1, false, 0);
        let m2 = thisConnector.getTransformationTo(toConnector2, false, 0);
        let vps1 = this._toVector3DPairs(m1);
        let vps2 = toCag._toVector3DPairs(m2);
        let polygons = [];
        vps1.forEach(function(vp1, i) {
          polygons.push(new Polygon([
            new Vertex3D(vps2[i][1]),
            new Vertex3D(vps2[i][0]),
            new Vertex3D(vp1[0])
          ]));
          polygons.push(new Polygon([
            new Vertex3D(vps2[i][1]),
            new Vertex3D(vp1[0]),
            new Vertex3D(vp1[1])
          ]));
        });
        return polygons;
      },
      /**
       * Convert to a list of points.
       * @return {points[]} list of points in 2D space
       */
      toPoints: function() {
        let points = this.sides.map(function(side) {
          let v0 = side.vertex0;
          return v0.pos;
        });
        if (points.length > 0) {
          points.push(points.shift());
        }
        return points;
      },
      /** Convert to compact binary form.
      * See fromCompactBinary.
      * @return {CompactBinary}
      */
      toCompactBinary: function() {
        let cag = this.canonicalized();
        let numsides = cag.sides.length;
        let vertexmap = {};
        let vertices = [];
        let numvertices = 0;
        let sideVertexIndices = new Uint32Array(2 * numsides);
        let sidevertexindicesindex = 0;
        cag.sides.map(function(side) {
          [side.vertex0, side.vertex1].map(function(v) {
            let vertextag = v.getTag();
            let vertexindex;
            if (!(vertextag in vertexmap)) {
              vertexindex = numvertices++;
              vertexmap[vertextag] = vertexindex;
              vertices.push(v);
            } else {
              vertexindex = vertexmap[vertextag];
            }
            sideVertexIndices[sidevertexindicesindex++] = vertexindex;
          });
        });
        let vertexData = new Float64Array(numvertices * 2);
        let verticesArrayIndex = 0;
        vertices.map(function(v) {
          let pos = v.pos;
          vertexData[verticesArrayIndex++] = pos._x;
          vertexData[verticesArrayIndex++] = pos._y;
        });
        let result = {
          "class": "CAG",
          sideVertexIndices,
          vertexData
        };
        return result;
      }
    };
    module.exports = CAG;
  }
});

// src/core/vendor/csg/src/core/math/Polygon2.js
var require_Polygon2 = __commonJS({
  "src/core/vendor/csg/src/core/math/Polygon2.js"(exports, module) {
    "use strict";
    var CAG = require_CAG();
    var { fromPoints } = require_CAGFactories();
    function Polygon2D(points) {
      const cag = fromPoints(points);
      this.sides = cag.sides;
    }
    Polygon2D.prototype = CAG.prototype;
    module.exports = Polygon2D;
  }
});

// src/core/vendor/csg/src/core/CSGFactories.js
var require_CSGFactories = __commonJS({
  "src/core/vendor/csg/src/core/CSGFactories.js"(exports, module) {
    "use strict";
    var Vector3D = require_Vector3();
    var Vertex = require_Vertex3();
    var Plane = require_Plane();
    var Polygon2D = require_Polygon2();
    var Polygon3D = require_Polygon3();
    var fromPolygons = function(polygons) {
      const CSG = require_CSG();
      let csg = new CSG();
      csg.polygons = polygons;
      csg.isCanonicalized = false;
      csg.isRetesselated = false;
      return csg;
    };
    function fromSlices(options) {
      return Polygon2D.createFromPoints([
        [0, 0, 0],
        [1, 0, 0],
        [1, 1, 0],
        [0, 1, 0]
      ]).solidFromSlices(options);
    }
    function fromObject(obj) {
      let polygons = obj.polygons.map(function(p) {
        return Polygon3D.fromObject(p);
      });
      let csg = fromPolygons(polygons);
      csg.isCanonicalized = obj.isCanonicalized;
      csg.isRetesselated = obj.isRetesselated;
      return csg;
    }
    function fromCompactBinary(bin) {
      if (bin["class"] !== "CSG") throw new Error("Not a CSG");
      let planes = [];
      let planeData = bin.planeData;
      let numplanes = planeData.length / 4;
      let arrayindex = 0;
      let x, y, z, w, normal, plane;
      for (let planeindex = 0; planeindex < numplanes; planeindex++) {
        x = planeData[arrayindex++];
        y = planeData[arrayindex++];
        z = planeData[arrayindex++];
        w = planeData[arrayindex++];
        normal = Vector3D.Create(x, y, z);
        plane = new Plane(normal, w);
        planes.push(plane);
      }
      let vertices = [];
      const vertexData = bin.vertexData;
      const numvertices = vertexData.length / 3;
      let pos;
      let vertex;
      arrayindex = 0;
      for (let vertexindex = 0; vertexindex < numvertices; vertexindex++) {
        x = vertexData[arrayindex++];
        y = vertexData[arrayindex++];
        z = vertexData[arrayindex++];
        pos = Vector3D.Create(x, y, z);
        vertex = new Vertex(pos);
        vertices.push(vertex);
      }
      let shareds = bin.shared.map(function(shared2) {
        return Polygon3D.Shared.fromObject(shared2);
      });
      let polygons = [];
      let numpolygons = bin.numPolygons;
      let numVerticesPerPolygon = bin.numVerticesPerPolygon;
      let polygonVertices = bin.polygonVertices;
      let polygonPlaneIndexes = bin.polygonPlaneIndexes;
      let polygonSharedIndexes = bin.polygonSharedIndexes;
      let numpolygonvertices;
      let polygonvertices;
      let shared;
      let polygon;
      arrayindex = 0;
      for (let polygonindex = 0; polygonindex < numpolygons; polygonindex++) {
        numpolygonvertices = numVerticesPerPolygon[polygonindex];
        polygonvertices = [];
        for (let i = 0; i < numpolygonvertices; i++) {
          polygonvertices.push(vertices[polygonVertices[arrayindex++]]);
        }
        plane = planes[polygonPlaneIndexes[polygonindex]];
        shared = shareds[polygonSharedIndexes[polygonindex]];
        polygon = new Polygon3D(polygonvertices, shared, plane);
        polygons.push(polygon);
      }
      let csg = fromPolygons(polygons);
      csg.isCanonicalized = true;
      csg.isRetesselated = true;
      return csg;
    }
    module.exports = {
      fromPolygons,
      fromSlices,
      fromObject,
      fromCompactBinary
    };
  }
});

// src/core/vendor/csg/src/api/solidFromSlices.js
var require_solidFromSlices = __commonJS({
  "src/core/vendor/csg/src/api/solidFromSlices.js"(exports, module) {
    "use strict";
    var Polygon = require_Polygon3();
    var { fromPolygons } = require_CSGFactories();
    var { fnSortByIndex } = require_utils();
    var solidFromSlices = function(polygon, options) {
      let polygons = [];
      let csg = null;
      let prev = null;
      let bottom = null;
      let top = null;
      let numSlices = 2;
      let bLoop = false;
      let fnCallback;
      let flipped = null;
      if (options) {
        bLoop = Boolean(options["loop"]);
        if (options.numslices) {
          numSlices = options.numslices;
        }
        if (options.callback) {
          fnCallback = options.callback;
        }
      }
      if (!fnCallback) {
        let square = Polygon.createFromPoints([
          [0, 0, 0],
          [1, 0, 0],
          [1, 1, 0],
          [0, 1, 0]
        ]);
        fnCallback = function(t, slice) {
          return t === 0 || t === 1 ? square.translate([0, 0, t]) : null;
        };
      }
      for (let i = 0, iMax = numSlices - 1; i <= iMax; i++) {
        csg = fnCallback.call(polygon, i / iMax, i);
        if (csg) {
          if (!(csg instanceof Polygon)) {
            throw new Error("Polygon.solidFromSlices callback error: Polygon expected");
          }
          csg.checkIfConvex();
          if (prev) {
            if (flipped === null) {
              flipped = prev.plane.signedDistanceToPoint(csg.vertices[0].pos) < 0;
            }
            _addWalls(polygons, prev, csg, flipped);
          } else {
            bottom = csg;
          }
          prev = csg;
        }
      }
      top = csg;
      if (bLoop) {
        let bSameTopBottom = bottom.vertices.length === top.vertices.length && bottom.vertices.every(function(v, index) {
          return v.pos.equals(top.vertices[index].pos);
        });
        if (!bSameTopBottom) {
          _addWalls(polygons, top, bottom, flipped);
        }
      } else {
        polygons.unshift(flipped ? bottom : bottom.flipped());
        polygons.push(flipped ? top.flipped() : top);
      }
      return fromPolygons(polygons);
    };
    var _addWalls = function(walls, bottom, top, bFlipped) {
      let bottomPoints = bottom.vertices.slice(0);
      let topPoints = top.vertices.slice(0);
      let color = top.shared || null;
      if (!bottomPoints[0].pos.equals(bottomPoints[bottomPoints.length - 1].pos)) {
        bottomPoints.push(bottomPoints[0]);
      }
      if (!topPoints[0].pos.equals(topPoints[topPoints.length - 1].pos)) {
        topPoints.push(topPoints[0]);
      }
      if (bFlipped) {
        bottomPoints = bottomPoints.reverse();
        topPoints = topPoints.reverse();
      }
      let iTopLen = topPoints.length - 1;
      let iBotLen = bottomPoints.length - 1;
      let iExtra = iTopLen - iBotLen;
      let bMoreTops = iExtra > 0;
      let bMoreBottoms = iExtra < 0;
      let aMin = [];
      for (let i = Math.abs(iExtra); i > 0; i--) {
        aMin.push({
          len: Infinity,
          index: -1
        });
      }
      let len;
      if (bMoreBottoms) {
        for (let i = 0; i < iBotLen; i++) {
          len = bottomPoints[i].pos.distanceToSquared(bottomPoints[i + 1].pos);
          for (let j = aMin.length - 1; j >= 0; j--) {
            if (aMin[j].len > len) {
              aMin[j].len = len;
              aMin.index = j;
              break;
            }
          }
        }
      } else if (bMoreTops) {
        for (let i = 0; i < iTopLen; i++) {
          len = topPoints[i].pos.distanceToSquared(topPoints[i + 1].pos);
          for (let j = aMin.length - 1; j >= 0; j--) {
            if (aMin[j].len > len) {
              aMin[j].len = len;
              aMin.index = j;
              break;
            }
          }
        }
      }
      aMin.sort(fnSortByIndex);
      let getTriangle = function addWallsPutTriangle(pointA, pointB, pointC, color2) {
        return new Polygon([pointA, pointB, pointC], color2);
      };
      let bpoint = bottomPoints[0];
      let tpoint = topPoints[0];
      let secondPoint;
      let nBotFacet;
      let nTopFacet;
      for (let iB = 0, iT = 0, iMax = iTopLen + iBotLen; iB + iT < iMax; ) {
        if (aMin.length) {
          if (bMoreTops && iT === aMin[0].index) {
            secondPoint = topPoints[++iT];
            walls.push(getTriangle(
              secondPoint,
              tpoint,
              bpoint,
              color
            ));
            tpoint = secondPoint;
            aMin.shift();
            continue;
          } else if (bMoreBottoms && iB === aMin[0].index) {
            secondPoint = bottomPoints[++iB];
            walls.push(getTriangle(
              tpoint,
              bpoint,
              secondPoint,
              color
            ));
            bpoint = secondPoint;
            aMin.shift();
            continue;
          }
        }
        if (iB < iBotLen) {
          nBotFacet = tpoint.pos.distanceToSquared(bottomPoints[iB + 1].pos);
        } else {
          nBotFacet = Infinity;
        }
        if (iT < iTopLen) {
          nTopFacet = bpoint.pos.distanceToSquared(topPoints[iT + 1].pos);
        } else {
          nTopFacet = Infinity;
        }
        if (nBotFacet <= nTopFacet) {
          secondPoint = bottomPoints[++iB];
          walls.push(getTriangle(
            tpoint,
            bpoint,
            secondPoint,
            color
          ));
          bpoint = secondPoint;
        } else if (iT < iTopLen) {
          secondPoint = topPoints[++iT];
          walls.push(getTriangle(
            secondPoint,
            tpoint,
            bpoint,
            color
          ));
          tpoint = secondPoint;
        }
        ;
      }
      return walls;
    };
    module.exports = solidFromSlices;
  }
});

// src/core/vendor/csg/src/core/math/Polygon3.js
var require_Polygon3 = __commonJS({
  "src/core/vendor/csg/src/core/math/Polygon3.js"(exports, module) {
    "use strict";
    var Vector3D = require_Vector3();
    var Vertex = require_Vertex3();
    var Matrix4x4 = require_Matrix4();
    var { _CSGDEBUG, EPS, getTag, areaEPS } = require_constants();
    var Polygon = function(vertices, shared, plane) {
      this.vertices = vertices;
      if (!shared) shared = Polygon.defaultShared;
      this.shared = shared;
      if (arguments.length >= 3) {
        this.plane = plane;
      } else {
        const Plane = require_Plane();
        this.plane = Plane.fromVector3Ds(vertices[0].pos, vertices[1].pos, vertices[2].pos);
      }
      if (_CSGDEBUG) {
        if (!this.checkIfConvex()) {
          throw new Error("Not convex!");
        }
      }
    };
    Polygon.prototype = {
      /** Check whether the polygon is convex. (it should be, otherwise we will get unexpected results)
       * @returns {boolean}
       */
      checkIfConvex: function() {
        return Polygon.verticesConvex(this.vertices, this.plane.normal);
      },
      // FIXME what? why does this return this, and not a new polygon?
      // FIXME is this used?
      setColor: function(args) {
        let newshared = Polygon.Shared.fromColor.apply(this, arguments);
        this.shared = newshared;
        return this;
      },
      getSignedVolume: function() {
        let signedVolume = 0;
        for (let i = 0; i < this.vertices.length - 2; i++) {
          signedVolume += this.vertices[0].pos.dot(this.vertices[i + 1].pos.cross(this.vertices[i + 2].pos));
        }
        signedVolume /= 6;
        return signedVolume;
      },
      // Note: could calculate vectors only once to speed up
      getArea: function() {
        let polygonArea = 0;
        for (let i = 0; i < this.vertices.length - 2; i++) {
          polygonArea += this.vertices[i + 1].pos.minus(this.vertices[0].pos).cross(this.vertices[i + 2].pos.minus(this.vertices[i + 1].pos)).length();
        }
        polygonArea /= 2;
        return polygonArea;
      },
      // accepts array of features to calculate
      // returns array of results
      getTetraFeatures: function(features) {
        let result = [];
        features.forEach(function(feature) {
          if (feature === "volume") {
            result.push(this.getSignedVolume());
          } else if (feature === "area") {
            result.push(this.getArea());
          }
        }, this);
        return result;
      },
      // Extrude a polygon into the direction offsetvector
      // Returns a CSG object
      extrude: function(offsetvector) {
        const { fromPolygons } = require_CSGFactories();
        let newpolygons = [];
        let polygon1 = this;
        let direction = polygon1.plane.normal.dot(offsetvector);
        if (direction > 0) {
          polygon1 = polygon1.flipped();
        }
        newpolygons.push(polygon1);
        let polygon2 = polygon1.translate(offsetvector);
        let numvertices = this.vertices.length;
        for (let i = 0; i < numvertices; i++) {
          let sidefacepoints = [];
          let nexti = i < numvertices - 1 ? i + 1 : 0;
          sidefacepoints.push(polygon1.vertices[i].pos);
          sidefacepoints.push(polygon2.vertices[i].pos);
          sidefacepoints.push(polygon2.vertices[nexti].pos);
          sidefacepoints.push(polygon1.vertices[nexti].pos);
          let sidefacepolygon = Polygon.createFromPoints(sidefacepoints, this.shared);
          newpolygons.push(sidefacepolygon);
        }
        polygon2 = polygon2.flipped();
        newpolygons.push(polygon2);
        return fromPolygons(newpolygons);
      },
      translate: function(offset) {
        return this.transform(Matrix4x4.translation(offset));
      },
      // returns an array with a Vector3D (center point) and a radius
      boundingSphere: function() {
        if (!this.cachedBoundingSphere) {
          let box = this.boundingBox();
          let middle = box[0].plus(box[1]).times(0.5);
          let radius3 = box[1].minus(middle);
          let radius = radius3.length();
          this.cachedBoundingSphere = [middle, radius];
        }
        return this.cachedBoundingSphere;
      },
      // returns an array of two Vector3Ds (minimum coordinates and maximum coordinates)
      boundingBox: function() {
        if (!this.cachedBoundingBox) {
          let minpoint, maxpoint;
          let vertices = this.vertices;
          let numvertices = vertices.length;
          if (numvertices === 0) {
            minpoint = new Vector3D(0, 0, 0);
          } else {
            minpoint = vertices[0].pos;
          }
          maxpoint = minpoint;
          for (let i = 1; i < numvertices; i++) {
            let point = vertices[i].pos;
            minpoint = minpoint.min(point);
            maxpoint = maxpoint.max(point);
          }
          this.cachedBoundingBox = [minpoint, maxpoint];
        }
        return this.cachedBoundingBox;
      },
      flipped: function() {
        let newvertices = this.vertices.map(function(v) {
          return v.flipped();
        });
        newvertices.reverse();
        let newplane = this.plane.flipped();
        return new Polygon(newvertices, this.shared, newplane);
      },
      // Affine transformation of polygon. Returns a new Polygon
      transform: function(matrix4x4) {
        let newvertices = this.vertices.map(function(v) {
          return v.transform(matrix4x4);
        });
        let newplane = this.plane.transform(matrix4x4);
        if (matrix4x4.isMirroring()) {
          newvertices.reverse();
        }
        return new Polygon(newvertices, this.shared, newplane);
      },
      toString: function() {
        let result = "Polygon plane: " + this.plane.toString() + "\n";
        this.vertices.map(function(vertex) {
          result += "  " + vertex.toString() + "\n";
        });
        return result;
      },
      // project the 3D polygon onto a plane
      projectToOrthoNormalBasis: function(orthobasis) {
        const CAG = require_CAG();
        const { fromPointsNoCheck } = require_CAGFactories();
        let points2d = this.vertices.map(function(vertex) {
          return orthobasis.to2D(vertex.pos);
        });
        let result = fromPointsNoCheck(points2d);
        let area = result.area();
        if (Math.abs(area) < areaEPS) {
          result = new CAG();
        } else if (area < 0) {
          result = result.flipped();
        }
        return result;
      },
      // ALIAS ONLY!!
      solidFromSlices: function(options) {
        const solidFromSlices = require_solidFromSlices();
        return solidFromSlices(this, options);
      }
    };
    Polygon.fromObject = function(obj) {
      const Plane = require_Plane();
      let vertices = obj.vertices.map(function(v) {
        return Vertex.fromObject(v);
      });
      let shared = Polygon.Shared.fromObject(obj.shared);
      let plane = Plane.fromObject(obj.plane);
      return new Polygon(vertices, shared, plane);
    };
    Polygon.createFromPoints = function(points, shared, plane) {
      let vertices = [];
      points.map(function(p) {
        let vec = new Vector3D(p);
        let vertex = new Vertex(vec);
        vertices.push(vertex);
      });
      let polygon;
      if (arguments.length < 3) {
        polygon = new Polygon(vertices, shared);
      } else {
        polygon = new Polygon(vertices, shared, plane);
      }
      return polygon;
    };
    Polygon.verticesConvex = function(vertices, planenormal) {
      let numvertices = vertices.length;
      if (numvertices > 2) {
        let prevprevpos = vertices[numvertices - 2].pos;
        let prevpos = vertices[numvertices - 1].pos;
        for (let i = 0; i < numvertices; i++) {
          let pos = vertices[i].pos;
          if (!Polygon.isConvexPoint(prevprevpos, prevpos, pos, planenormal)) {
            return false;
          }
          prevprevpos = prevpos;
          prevpos = pos;
        }
      }
      return true;
    };
    Polygon.isConvexPoint = function(prevpoint, point, nextpoint, normal) {
      let crossproduct = point.minus(prevpoint).cross(nextpoint.minus(point));
      let crossdotnormal = crossproduct.dot(normal);
      return crossdotnormal >= 0;
    };
    Polygon.isStrictlyConvexPoint = function(prevpoint, point, nextpoint, normal) {
      let crossproduct = point.minus(prevpoint).cross(nextpoint.minus(point));
      let crossdotnormal = crossproduct.dot(normal);
      return crossdotnormal >= EPS;
    };
    Polygon.Shared = function(color) {
      if (color !== null && color !== void 0) {
        if (color.length !== 4) {
          throw new Error("Expecting 4 element array");
        }
      }
      this.color = color;
    };
    Polygon.Shared.fromObject = function(obj) {
      return new Polygon.Shared(obj.color);
    };
    Polygon.Shared.fromColor = function(args) {
      let color;
      if (arguments.length === 1) {
        color = arguments[0].slice();
      } else {
        color = [];
        for (let i = 0; i < arguments.length; i++) {
          color.push(arguments[i]);
        }
      }
      if (color.length === 3) {
        color.push(1);
      } else if (color.length !== 4) {
        throw new Error("setColor expects either an array with 3 or 4 elements, or 3 or 4 parameters.");
      }
      return new Polygon.Shared(color);
    };
    Polygon.Shared.prototype = {
      getTag: function() {
        let result = this.tag;
        if (!result) {
          result = getTag();
          this.tag = result;
        }
        return result;
      },
      // get a string uniquely identifying this object
      getHash: function() {
        if (!this.color) return "null";
        return this.color.join("/");
      }
    };
    Polygon.defaultShared = new Polygon.Shared(null);
    module.exports = Polygon;
  }
});

// src/core/vendor/csg/src/core/trees.js
var require_trees = __commonJS({
  "src/core/vendor/csg/src/core/trees.js"(exports, module) {
    "use strict";
    var { _CSGDEBUG, EPS } = require_constants();
    var Vertex = require_Vertex3();
    var Polygon = require_Polygon3();
    function splitPolygonByPlane(plane, polygon) {
      let result = {
        type: null,
        front: null,
        back: null
      };
      let planenormal = plane.normal;
      let vertices = polygon.vertices;
      let numvertices = vertices.length;
      if (polygon.plane.equals(plane)) {
        result.type = 0;
      } else {
        let thisw = plane.w;
        let hasfront = false;
        let hasback = false;
        let vertexIsBack = [];
        let MINEPS = -EPS;
        for (let i = 0; i < numvertices; i++) {
          let t = planenormal.dot(vertices[i].pos) - thisw;
          let isback = t < 0;
          vertexIsBack.push(isback);
          if (t > EPS) hasfront = true;
          if (t < MINEPS) hasback = true;
        }
        if (!hasfront && !hasback) {
          let t = planenormal.dot(polygon.plane.normal);
          result.type = t >= 0 ? 0 : 1;
        } else if (!hasback) {
          result.type = 2;
        } else if (!hasfront) {
          result.type = 3;
        } else {
          result.type = 4;
          let frontvertices = [];
          let backvertices = [];
          let isback = vertexIsBack[0];
          for (let vertexindex = 0; vertexindex < numvertices; vertexindex++) {
            let vertex = vertices[vertexindex];
            let nextvertexindex = vertexindex + 1;
            if (nextvertexindex >= numvertices) nextvertexindex = 0;
            let nextisback = vertexIsBack[nextvertexindex];
            if (isback === nextisback) {
              if (isback) {
                backvertices.push(vertex);
              } else {
                frontvertices.push(vertex);
              }
            } else {
              let point = vertex.pos;
              let nextpoint = vertices[nextvertexindex].pos;
              let intersectionpoint = plane.splitLineBetweenPoints(point, nextpoint);
              let intersectionvertex = new Vertex(intersectionpoint);
              if (isback) {
                backvertices.push(vertex);
                backvertices.push(intersectionvertex);
                frontvertices.push(intersectionvertex);
              } else {
                frontvertices.push(vertex);
                frontvertices.push(intersectionvertex);
                backvertices.push(intersectionvertex);
              }
            }
            isback = nextisback;
          }
          let EPS_SQUARED = EPS * EPS;
          if (backvertices.length >= 3) {
            let prevvertex = backvertices[backvertices.length - 1];
            for (let vertexindex = 0; vertexindex < backvertices.length; vertexindex++) {
              let vertex = backvertices[vertexindex];
              if (vertex.pos.distanceToSquared(prevvertex.pos) < EPS_SQUARED) {
                backvertices.splice(vertexindex, 1);
                vertexindex--;
              }
              prevvertex = vertex;
            }
          }
          if (frontvertices.length >= 3) {
            let prevvertex = frontvertices[frontvertices.length - 1];
            for (let vertexindex = 0; vertexindex < frontvertices.length; vertexindex++) {
              let vertex = frontvertices[vertexindex];
              if (vertex.pos.distanceToSquared(prevvertex.pos) < EPS_SQUARED) {
                frontvertices.splice(vertexindex, 1);
                vertexindex--;
              }
              prevvertex = vertex;
            }
          }
          if (frontvertices.length >= 3) {
            result.front = new Polygon(frontvertices, polygon.shared, polygon.plane);
          }
          if (backvertices.length >= 3) {
            result.back = new Polygon(backvertices, polygon.shared, polygon.plane);
          }
        }
      }
      return result;
    }
    var PolygonTreeNode = function() {
      this.parent = null;
      this.children = [];
      this.polygon = null;
      this.removed = false;
    };
    PolygonTreeNode.prototype = {
      // fill the tree with polygons. Should be called on the root node only; child nodes must
      // always be a derivate (split) of the parent node.
      addPolygons: function(polygons) {
        if (!this.isRootNode()) {
          throw new Error("Assertion failed");
        }
        let _this = this;
        polygons.map(function(polygon) {
          _this.addChild(polygon);
        });
      },
      // remove a node
      // - the siblings become toplevel nodes
      // - the parent is removed recursively
      remove: function() {
        if (!this.removed) {
          this.removed = true;
          if (_CSGDEBUG) {
            if (this.isRootNode()) throw new Error("Assertion failed");
            if (this.children.length) throw new Error("Assertion failed");
          }
          let parentschildren = this.parent.children;
          let i = parentschildren.indexOf(this);
          if (i < 0) throw new Error("Assertion failed");
          parentschildren.splice(i, 1);
          this.parent.recursivelyInvalidatePolygon();
        }
      },
      isRemoved: function() {
        return this.removed;
      },
      isRootNode: function() {
        return !this.parent;
      },
      // invert all polygons in the tree. Call on the root node
      invert: function() {
        if (!this.isRootNode()) throw new Error("Assertion failed");
        this.invertSub();
      },
      getPolygon: function() {
        if (!this.polygon) throw new Error("Assertion failed");
        return this.polygon;
      },
      getPolygons: function(result) {
        let children = [this];
        let queue = [children];
        let i, j, l, node;
        for (i = 0; i < queue.length; ++i) {
          children = queue[i];
          for (j = 0, l = children.length; j < l; j++) {
            node = children[j];
            if (node.polygon) {
              result.push(node.polygon);
            } else {
              queue.push(node.children);
            }
          }
        }
      },
      // split the node by a plane; add the resulting nodes to the frontnodes and backnodes array
      // If the plane doesn't intersect the polygon, the 'this' object is added to one of the arrays
      // If the plane does intersect the polygon, two new child nodes are created for the front and back fragments,
      //  and added to both arrays.
      splitByPlane: function(plane, coplanarfrontnodes, coplanarbacknodes, frontnodes, backnodes) {
        if (this.children.length) {
          let queue = [this.children];
          let i;
          let j;
          let l;
          let node;
          let nodes;
          for (i = 0; i < queue.length; i++) {
            nodes = queue[i];
            for (j = 0, l = nodes.length; j < l; j++) {
              node = nodes[j];
              if (node.children.length) {
                queue.push(node.children);
              } else {
                node._splitByPlane(plane, coplanarfrontnodes, coplanarbacknodes, frontnodes, backnodes);
              }
            }
          }
        } else {
          this._splitByPlane(plane, coplanarfrontnodes, coplanarbacknodes, frontnodes, backnodes);
        }
      },
      // only to be called for nodes with no children
      _splitByPlane: function(plane, coplanarfrontnodes, coplanarbacknodes, frontnodes, backnodes) {
        let polygon = this.polygon;
        if (polygon) {
          let bound = polygon.boundingSphere();
          let sphereradius = bound[1] + EPS;
          let planenormal = plane.normal;
          let spherecenter = bound[0];
          let d = planenormal.dot(spherecenter) - plane.w;
          if (d > sphereradius) {
            frontnodes.push(this);
          } else if (d < -sphereradius) {
            backnodes.push(this);
          } else {
            let splitresult = splitPolygonByPlane(plane, polygon);
            switch (splitresult.type) {
              case 0:
                coplanarfrontnodes.push(this);
                break;
              case 1:
                coplanarbacknodes.push(this);
                break;
              case 2:
                frontnodes.push(this);
                break;
              case 3:
                backnodes.push(this);
                break;
              case 4:
                if (splitresult.front) {
                  let frontnode = this.addChild(splitresult.front);
                  frontnodes.push(frontnode);
                }
                if (splitresult.back) {
                  let backnode = this.addChild(splitresult.back);
                  backnodes.push(backnode);
                }
                break;
            }
          }
        }
      },
      // PRIVATE methods from here:
      // add child to a node
      // this should be called whenever the polygon is split
      // a child should be created for every fragment of the split polygon
      // returns the newly created child
      addChild: function(polygon) {
        let newchild = new PolygonTreeNode();
        newchild.parent = this;
        newchild.polygon = polygon;
        this.children.push(newchild);
        return newchild;
      },
      invertSub: function() {
        let children = [this];
        let queue = [children];
        let i, j, l, node;
        for (i = 0; i < queue.length; i++) {
          children = queue[i];
          for (j = 0, l = children.length; j < l; j++) {
            node = children[j];
            if (node.polygon) {
              node.polygon = node.polygon.flipped();
            }
            queue.push(node.children);
          }
        }
      },
      recursivelyInvalidatePolygon: function() {
        let node = this;
        while (node.polygon) {
          node.polygon = null;
          if (node.parent) {
            node = node.parent;
          }
        }
      }
    };
    var Tree = function(polygons) {
      this.polygonTree = new PolygonTreeNode();
      this.rootnode = new Node(null);
      if (polygons) this.addPolygons(polygons);
    };
    Tree.prototype = {
      invert: function() {
        this.polygonTree.invert();
        this.rootnode.invert();
      },
      // Remove all polygons in this BSP tree that are inside the other BSP tree
      // `tree`.
      clipTo: function(tree, alsoRemovecoplanarFront) {
        alsoRemovecoplanarFront = !!alsoRemovecoplanarFront;
        this.rootnode.clipTo(tree, alsoRemovecoplanarFront);
      },
      allPolygons: function() {
        let result = [];
        this.polygonTree.getPolygons(result);
        return result;
      },
      addPolygons: function(polygons) {
        let _this = this;
        let polygontreenodes = polygons.map(function(p) {
          return _this.polygonTree.addChild(p);
        });
        this.rootnode.addPolygonTreeNodes(polygontreenodes);
      }
    };
    var Node = function(parent) {
      this.plane = null;
      this.front = null;
      this.back = null;
      this.polygontreenodes = [];
      this.parent = parent;
    };
    Node.prototype = {
      // Convert solid space to empty space and empty space to solid space.
      invert: function() {
        let queue = [this];
        let node;
        for (let i = 0; i < queue.length; i++) {
          node = queue[i];
          if (node.plane) node.plane = node.plane.flipped();
          if (node.front) queue.push(node.front);
          if (node.back) queue.push(node.back);
          let temp = node.front;
          node.front = node.back;
          node.back = temp;
        }
      },
      // clip polygontreenodes to our plane
      // calls remove() for all clipped PolygonTreeNodes
      clipPolygons: function(polygontreenodes, alsoRemovecoplanarFront) {
        let args = { "node": this, "polygontreenodes": polygontreenodes };
        let node;
        let stack = [];
        do {
          node = args.node;
          polygontreenodes = args.polygontreenodes;
          if (node.plane) {
            let backnodes = [];
            let frontnodes = [];
            let coplanarfrontnodes = alsoRemovecoplanarFront ? backnodes : frontnodes;
            let plane = node.plane;
            let numpolygontreenodes = polygontreenodes.length;
            for (let i = 0; i < numpolygontreenodes; i++) {
              let node1 = polygontreenodes[i];
              if (!node1.isRemoved()) {
                node1.splitByPlane(plane, coplanarfrontnodes, backnodes, frontnodes, backnodes);
              }
            }
            if (node.front && frontnodes.length > 0) {
              stack.push({ "node": node.front, "polygontreenodes": frontnodes });
            }
            let numbacknodes = backnodes.length;
            if (node.back && numbacknodes > 0) {
              stack.push({ "node": node.back, "polygontreenodes": backnodes });
            } else {
              for (let i = 0; i < numbacknodes; i++) {
                backnodes[i].remove();
              }
            }
          }
          args = stack.pop();
        } while (typeof args !== "undefined");
      },
      // Remove all polygons in this BSP tree that are inside the other BSP tree
      // `tree`.
      clipTo: function(tree, alsoRemovecoplanarFront) {
        let node = this;
        let stack = [];
        do {
          if (node.polygontreenodes.length > 0) {
            tree.rootnode.clipPolygons(node.polygontreenodes, alsoRemovecoplanarFront);
          }
          if (node.front) stack.push(node.front);
          if (node.back) stack.push(node.back);
          node = stack.pop();
        } while (typeof node !== "undefined");
      },
      addPolygonTreeNodes: function(polygontreenodes) {
        let args = { "node": this, "polygontreenodes": polygontreenodes };
        let node;
        let stack = [];
        do {
          node = args.node;
          polygontreenodes = args.polygontreenodes;
          if (polygontreenodes.length === 0) {
            args = stack.pop();
            continue;
          }
          let _this = node;
          if (!node.plane) {
            let bestplane = polygontreenodes[0].getPolygon().plane;
            node.plane = bestplane;
          }
          let frontnodes = [];
          let backnodes = [];
          for (let i = 0, n = polygontreenodes.length; i < n; ++i) {
            polygontreenodes[i].splitByPlane(_this.plane, _this.polygontreenodes, backnodes, frontnodes, backnodes);
          }
          if (frontnodes.length > 0) {
            if (!node.front) node.front = new Node(node);
            stack.push({ "node": node.front, "polygontreenodes": frontnodes });
          }
          if (backnodes.length > 0) {
            if (!node.back) node.back = new Node(node);
            stack.push({ "node": node.back, "polygontreenodes": backnodes });
          }
          args = stack.pop();
        } while (typeof args !== "undefined");
      },
      getParentPlaneNormals: function(normals, maxdepth) {
        if (maxdepth > 0) {
          if (this.parent) {
            normals.push(this.parent.plane.normal);
            this.parent.getParentPlaneNormals(normals, maxdepth - 1);
          }
        }
      }
    };
    module.exports = Tree;
  }
});

// src/core/vendor/csg/src/core/Properties.js
var require_Properties = __commonJS({
  "src/core/vendor/csg/src/core/Properties.js"(exports, module) {
    "use strict";
    var Properties = function() {
    };
    Properties.prototype = {
      _transform: function(matrix4x4) {
        let result = new Properties();
        Properties.transformObj(this, result, matrix4x4);
        return result;
      },
      _merge: function(otherproperties) {
        let result = new Properties();
        Properties.cloneObj(this, result);
        Properties.addFrom(result, otherproperties);
        return result;
      }
    };
    Properties.transformObj = function(source, result, matrix4x4) {
      for (let propertyname in source) {
        if (propertyname === "_transform") continue;
        if (propertyname === "_merge") continue;
        let propertyvalue = source[propertyname];
        let transformed = propertyvalue;
        if (typeof propertyvalue === "object") {
          if ("transform" in propertyvalue && typeof propertyvalue.transform === "function") {
            transformed = propertyvalue.transform(matrix4x4);
          } else if (propertyvalue instanceof Array) {
            transformed = [];
            Properties.transformObj(propertyvalue, transformed, matrix4x4);
          } else if (propertyvalue instanceof Properties) {
            transformed = new Properties();
            Properties.transformObj(propertyvalue, transformed, matrix4x4);
          }
        }
        result[propertyname] = transformed;
      }
    };
    Properties.cloneObj = function(source, result) {
      for (let propertyname in source) {
        if (propertyname === "_transform") continue;
        if (propertyname === "_merge") continue;
        let propertyvalue = source[propertyname];
        let cloned = propertyvalue;
        if (typeof propertyvalue === "object") {
          if (propertyvalue instanceof Array) {
            cloned = [];
            for (let i = 0; i < propertyvalue.length; i++) {
              cloned.push(propertyvalue[i]);
            }
          } else if (propertyvalue instanceof Properties) {
            cloned = new Properties();
            Properties.cloneObj(propertyvalue, cloned);
          }
        }
        result[propertyname] = cloned;
      }
    };
    Properties.addFrom = function(result, otherproperties) {
      for (let propertyname in otherproperties) {
        if (propertyname === "_transform") continue;
        if (propertyname === "_merge") continue;
        if (propertyname in result && typeof result[propertyname] === "object" && result[propertyname] instanceof Properties && typeof otherproperties[propertyname] === "object" && otherproperties[propertyname] instanceof Properties) {
          Properties.addFrom(result[propertyname], otherproperties[propertyname]);
        } else if (!(propertyname in result)) {
          result[propertyname] = otherproperties[propertyname];
        }
      }
    };
    module.exports = Properties;
  }
});

// src/core/vendor/csg/src/core/utils/fixTJunctions.js
var require_fixTJunctions = __commonJS({
  "src/core/vendor/csg/src/core/utils/fixTJunctions.js"(exports, module) {
    "use strict";
    var { EPS } = require_constants();
    var Polygon = require_Polygon3();
    var Plane = require_Plane();
    function addSide(sidemap, vertextag2sidestart, vertextag2sideend, vertex0, vertex1, polygonindex) {
      let starttag = vertex0.getTag();
      let endtag = vertex1.getTag();
      if (starttag === endtag) throw new Error("Assertion failed");
      let newsidetag = starttag + "/" + endtag;
      let reversesidetag = endtag + "/" + starttag;
      if (reversesidetag in sidemap) {
        deleteSide(sidemap, vertextag2sidestart, vertextag2sideend, vertex1, vertex0, null);
        return null;
      }
      let newsideobj = {
        vertex0,
        vertex1,
        polygonindex
      };
      if (!(newsidetag in sidemap)) {
        sidemap[newsidetag] = [newsideobj];
      } else {
        sidemap[newsidetag].push(newsideobj);
      }
      if (starttag in vertextag2sidestart) {
        vertextag2sidestart[starttag].push(newsidetag);
      } else {
        vertextag2sidestart[starttag] = [newsidetag];
      }
      if (endtag in vertextag2sideend) {
        vertextag2sideend[endtag].push(newsidetag);
      } else {
        vertextag2sideend[endtag] = [newsidetag];
      }
      return newsidetag;
    }
    function deleteSide(sidemap, vertextag2sidestart, vertextag2sideend, vertex0, vertex1, polygonindex) {
      let starttag = vertex0.getTag();
      let endtag = vertex1.getTag();
      let sidetag = starttag + "/" + endtag;
      if (!(sidetag in sidemap)) throw new Error("Assertion failed");
      let idx = -1;
      let sideobjs = sidemap[sidetag];
      for (let i = 0; i < sideobjs.length; i++) {
        let sideobj = sideobjs[i];
        if (sideobj.vertex0 !== vertex0) continue;
        if (sideobj.vertex1 !== vertex1) continue;
        if (polygonindex !== null) {
          if (sideobj.polygonindex !== polygonindex) continue;
        }
        idx = i;
        break;
      }
      if (idx < 0) throw new Error("Assertion failed");
      sideobjs.splice(idx, 1);
      if (sideobjs.length === 0) {
        delete sidemap[sidetag];
      }
      idx = vertextag2sidestart[starttag].indexOf(sidetag);
      if (idx < 0) throw new Error("Assertion failed");
      vertextag2sidestart[starttag].splice(idx, 1);
      if (vertextag2sidestart[starttag].length === 0) {
        delete vertextag2sidestart[starttag];
      }
      idx = vertextag2sideend[endtag].indexOf(sidetag);
      if (idx < 0) throw new Error("Assertion failed");
      vertextag2sideend[endtag].splice(idx, 1);
      if (vertextag2sideend[endtag].length === 0) {
        delete vertextag2sideend[endtag];
      }
    }
    var fixTJunctions = function(fromPolygons, csg) {
      csg = csg.canonicalized();
      let sidemap = {};
      for (let polygonindex = 0; polygonindex < csg.polygons.length; polygonindex++) {
        let polygon = csg.polygons[polygonindex];
        let numvertices = polygon.vertices.length;
        if (numvertices >= 3) {
          let vertex = polygon.vertices[0];
          let vertextag = vertex.getTag();
          for (let vertexindex = 0; vertexindex < numvertices; vertexindex++) {
            let nextvertexindex = vertexindex + 1;
            if (nextvertexindex === numvertices) nextvertexindex = 0;
            let nextvertex = polygon.vertices[nextvertexindex];
            let nextvertextag = nextvertex.getTag();
            let sidetag = vertextag + "/" + nextvertextag;
            let reversesidetag = nextvertextag + "/" + vertextag;
            if (reversesidetag in sidemap) {
              let ar = sidemap[reversesidetag];
              ar.splice(-1, 1);
              if (ar.length === 0) {
                delete sidemap[reversesidetag];
              }
            } else {
              let sideobj = {
                vertex0: vertex,
                vertex1: nextvertex,
                polygonindex
              };
              if (!(sidetag in sidemap)) {
                sidemap[sidetag] = [sideobj];
              } else {
                sidemap[sidetag].push(sideobj);
              }
            }
            vertex = nextvertex;
            vertextag = nextvertextag;
          }
        }
      }
      let vertextag2sidestart = {};
      let vertextag2sideend = {};
      let sidestocheck = {};
      let sidemapisempty = true;
      for (let sidetag in sidemap) {
        sidemapisempty = false;
        sidestocheck[sidetag] = true;
        sidemap[sidetag].map(function(sideobj) {
          let starttag = sideobj.vertex0.getTag();
          let endtag = sideobj.vertex1.getTag();
          if (starttag in vertextag2sidestart) {
            vertextag2sidestart[starttag].push(sidetag);
          } else {
            vertextag2sidestart[starttag] = [sidetag];
          }
          if (endtag in vertextag2sideend) {
            vertextag2sideend[endtag].push(sidetag);
          } else {
            vertextag2sideend[endtag] = [sidetag];
          }
        });
      }
      if (!sidemapisempty) {
        let polygons = csg.polygons.slice(0);
        while (true) {
          let sidemapisempty2 = true;
          for (let sidetag in sidemap) {
            sidemapisempty2 = false;
            sidestocheck[sidetag] = true;
          }
          if (sidemapisempty2) break;
          let donesomething = false;
          while (true) {
            let sidetagtocheck = null;
            for (let sidetag in sidestocheck) {
              sidetagtocheck = sidetag;
              break;
            }
            if (sidetagtocheck === null) break;
            let donewithside = true;
            if (sidetagtocheck in sidemap) {
              let sideobjs = sidemap[sidetagtocheck];
              if (sideobjs.length === 0) throw new Error("Assertion failed");
              let sideobj = sideobjs[0];
              for (let directionindex = 0; directionindex < 2; directionindex++) {
                let startvertex = directionindex === 0 ? sideobj.vertex0 : sideobj.vertex1;
                let endvertex = directionindex === 0 ? sideobj.vertex1 : sideobj.vertex0;
                let startvertextag = startvertex.getTag();
                let endvertextag = endvertex.getTag();
                let matchingsides = [];
                if (directionindex === 0) {
                  if (startvertextag in vertextag2sideend) {
                    matchingsides = vertextag2sideend[startvertextag];
                  }
                } else {
                  if (startvertextag in vertextag2sidestart) {
                    matchingsides = vertextag2sidestart[startvertextag];
                  }
                }
                for (let matchingsideindex = 0; matchingsideindex < matchingsides.length; matchingsideindex++) {
                  let matchingsidetag = matchingsides[matchingsideindex];
                  let matchingside = sidemap[matchingsidetag][0];
                  let matchingsidestartvertex = directionindex === 0 ? matchingside.vertex0 : matchingside.vertex1;
                  let matchingsideendvertex = directionindex === 0 ? matchingside.vertex1 : matchingside.vertex0;
                  let matchingsidestartvertextag = matchingsidestartvertex.getTag();
                  let matchingsideendvertextag = matchingsideendvertex.getTag();
                  if (matchingsideendvertextag !== startvertextag) throw new Error("Assertion failed");
                  if (matchingsidestartvertextag === endvertextag) {
                    deleteSide(sidemap, vertextag2sidestart, vertextag2sideend, startvertex, endvertex, null);
                    deleteSide(sidemap, vertextag2sidestart, vertextag2sideend, endvertex, startvertex, null);
                    donewithside = false;
                    directionindex = 2;
                    donesomething = true;
                    break;
                  } else {
                    let startpos = startvertex.pos;
                    let endpos = endvertex.pos;
                    let checkpos = matchingsidestartvertex.pos;
                    let direction = checkpos.minus(startpos);
                    let t = endpos.minus(startpos).dot(direction) / direction.dot(direction);
                    if (t > 0 && t < 1) {
                      let closestpoint = startpos.plus(direction.times(t));
                      let distancesquared = closestpoint.distanceToSquared(endpos);
                      if (distancesquared < EPS * EPS) {
                        let polygonindex = matchingside.polygonindex;
                        let polygon = polygons[polygonindex];
                        let insertionvertextag = matchingside.vertex1.getTag();
                        let insertionvertextagindex = -1;
                        for (let i = 0; i < polygon.vertices.length; i++) {
                          if (polygon.vertices[i].getTag() === insertionvertextag) {
                            insertionvertextagindex = i;
                            break;
                          }
                        }
                        if (insertionvertextagindex < 0) throw new Error("Assertion failed");
                        let newvertices = polygon.vertices.slice(0);
                        newvertices.splice(insertionvertextagindex, 0, endvertex);
                        let newpolygon = new Polygon(
                          newvertices,
                          polygon.shared
                          /* polygon.plane */
                        );
                        if (isNaN(newpolygon.plane.w)) {
                          let found = false;
                          let loop = function(callback) {
                            newpolygon.vertices.forEach(function(item) {
                              if (found) return;
                              callback(item);
                            });
                          };
                          loop(function(a) {
                            loop(function(b) {
                              loop(function(c) {
                                newpolygon.plane = Plane.fromPoints(a.pos, b.pos, c.pos);
                                if (!isNaN(newpolygon.plane.w)) {
                                  found = true;
                                }
                              });
                            });
                          });
                        }
                        polygons[polygonindex] = newpolygon;
                        deleteSide(sidemap, vertextag2sidestart, vertextag2sideend, matchingside.vertex0, matchingside.vertex1, polygonindex);
                        let newsidetag1 = addSide(sidemap, vertextag2sidestart, vertextag2sideend, matchingside.vertex0, endvertex, polygonindex);
                        let newsidetag2 = addSide(sidemap, vertextag2sidestart, vertextag2sideend, endvertex, matchingside.vertex1, polygonindex);
                        if (newsidetag1 !== null) sidestocheck[newsidetag1] = true;
                        if (newsidetag2 !== null) sidestocheck[newsidetag2] = true;
                        donewithside = false;
                        directionindex = 2;
                        donesomething = true;
                        break;
                      }
                    }
                  }
                }
              }
            }
            if (donewithside) {
              delete sidestocheck[sidetagtocheck];
            }
          }
          if (!donesomething) break;
        }
        let newcsg = fromPolygons(polygons);
        newcsg.properties = csg.properties;
        newcsg.isCanonicalized = true;
        newcsg.isRetesselated = true;
        csg = newcsg;
      }
      return csg;
    };
    module.exports = fixTJunctions;
  }
});

// src/core/vendor/csg/src/core/utils/csgMeasurements.js
var require_csgMeasurements = __commonJS({
  "src/core/vendor/csg/src/core/utils/csgMeasurements.js"(exports, module) {
    "use strict";
    var Vector3D = require_Vector3();
    var bounds = function(csg) {
      if (!csg.cachedBoundingBox) {
        let minpoint = new Vector3D(0, 0, 0);
        let maxpoint = new Vector3D(0, 0, 0);
        let polygons = csg.polygons;
        let numpolygons = polygons.length;
        for (let i = 0; i < numpolygons; i++) {
          let polygon = polygons[i];
          let bounds2 = polygon.boundingBox();
          if (i === 0) {
            minpoint = bounds2[0];
            maxpoint = bounds2[1];
          } else {
            minpoint = minpoint.min(bounds2[0]);
            maxpoint = maxpoint.max(bounds2[1]);
          }
        }
        csg.cachedBoundingBox = [minpoint, maxpoint];
      }
      return csg.cachedBoundingBox;
    };
    var volume = function(csg) {
      let result = csg.toTriangles().map(function(triPoly) {
        return triPoly.getTetraFeatures(["volume"]);
      });
      console.log("volume", result);
    };
    var area = function(csg) {
      let result = csg.toTriangles().map(function(triPoly) {
        return triPoly.getTetraFeatures(["area"]);
      });
      console.log("area", result);
    };
    module.exports = { bounds, volume, area };
  }
});

// src/core/vendor/csg/src/core/utils/csgProjections.js
var require_csgProjections = __commonJS({
  "src/core/vendor/csg/src/core/utils/csgProjections.js"(exports, module) {
    "use strict";
    var CAG = require_CAG();
    var { EPS } = require_constants();
    var projectToOrthoNormalBasis = function(csg, orthobasis) {
      let cags = [];
      csg.polygons.filter(function(p) {
        return p.plane.normal.minus(orthobasis.plane.normal).lengthSquared() < EPS * EPS;
      }).map(function(polygon) {
        let cag = polygon.projectToOrthoNormalBasis(orthobasis);
        if (cag.sides.length > 0) {
          cags.push(cag);
        }
      });
      let result = new CAG().union(cags);
      return result;
    };
    module.exports = { projectToOrthoNormalBasis };
  }
});

// src/core/vendor/csg/src/api/ops-cuts.js
var require_ops_cuts = __commonJS({
  "src/core/vendor/csg/src/api/ops-cuts.js"(exports, module) {
    "use strict";
    var { EPS } = require_constants();
    var Plane = require_Plane();
    var Vector2 = require_Vector2();
    var Vertex3 = require_Vertex3();
    var Polygon3 = require_Polygon3();
    var OrthoNormalBasis = require_OrthoNormalBasis();
    var sectionCut = function(csg, orthobasis) {
      let plane1 = orthobasis.plane;
      let plane2 = orthobasis.plane.flipped();
      plane1 = new Plane(plane1.normal, plane1.w);
      plane2 = new Plane(plane2.normal, plane2.w + 5 * EPS);
      let cut3d = csg.cutByPlane(plane1);
      cut3d = cut3d.cutByPlane(plane2);
      return cut3d.projectToOrthoNormalBasis(orthobasis);
    };
    var cutByPlane = function(csg, plane) {
      if (csg.polygons.length === 0) {
        const CSG = require_CSG();
        return new CSG();
      }
      let planecenter = plane.normal.times(plane.w);
      let maxdistance = 0;
      csg.polygons.map(function(polygon2) {
        polygon2.vertices.map(function(vertex) {
          let distance = vertex.pos.distanceToSquared(planecenter);
          if (distance > maxdistance) maxdistance = distance;
        });
      });
      maxdistance = Math.sqrt(maxdistance);
      maxdistance *= 1.01;
      let vertices = [];
      let orthobasis = new OrthoNormalBasis(plane);
      vertices.push(new Vertex3(orthobasis.to3D(new Vector2(maxdistance, -maxdistance))));
      vertices.push(new Vertex3(orthobasis.to3D(new Vector2(-maxdistance, -maxdistance))));
      vertices.push(new Vertex3(orthobasis.to3D(new Vector2(-maxdistance, maxdistance))));
      vertices.push(new Vertex3(orthobasis.to3D(new Vector2(maxdistance, maxdistance))));
      const polygon = new Polygon3(vertices, null, plane.flipped());
      const cube = polygon.extrude(plane.normal.times(-maxdistance));
      let result = csg.intersect(cube);
      result.properties = csg.properties;
      return result;
    };
    module.exports = { sectionCut, cutByPlane };
  }
});

// src/core/vendor/csg/src/core/CSG.js
var require_CSG = __commonJS({
  "src/core/vendor/csg/src/core/CSG.js"(exports, module) {
    "use strict";
    var Tree = require_trees();
    var Polygon = require_Polygon3();
    var Plane = require_Plane();
    var OrthoNormalBasis = require_OrthoNormalBasis();
    var CAG = require_CAG();
    var Properties = require_Properties();
    var { fromPolygons } = require_CSGFactories();
    var fixTJunctions = require_fixTJunctions();
    var canonicalize = require_canonicalize();
    var retesselate = require_retesellate();
    var { bounds } = require_csgMeasurements();
    var { projectToOrthoNormalBasis } = require_csgProjections();
    var { lieFlat, getTransformationToFlatLying, getTransformationAndInverseTransformationToFlatLying } = require_ops_cnc();
    var { sectionCut, cutByPlane } = require_ops_cuts();
    var center = require_center();
    var { expand, contract, expandedShellOfCCSG } = require_ops_expandContract();
    var CSG = function() {
      this.polygons = [];
      this.properties = new Properties();
      this.isCanonicalized = true;
      this.isRetesselated = true;
    };
    CSG.prototype = {
      /**
       * Return a new CSG solid representing the space in either this solid or
       * in the given solids. Neither this solid nor the given solids are modified.
       * @param {CSG[]} csg - list of CSG objects
       * @returns {CSG} new CSG object
       * @example
       * let C = A.union(B)
       * @example
       * +-------+            +-------+
       * |       |            |       |
       * |   A   |            |       |
       * |    +--+----+   =   |       +----+
       * +----+--+    |       +----+       |
       *      |   B   |            |       |
       *      |       |            |       |
       *      +-------+            +-------+
       */
      union: function(csg) {
        let csgs;
        if (csg instanceof Array) {
          csgs = csg.slice(0);
          csgs.push(this);
        } else {
          csgs = [this, csg];
        }
        let i;
        for (i = 1; i < csgs.length; i += 2) {
          csgs.push(csgs[i - 1].unionSub(csgs[i]));
        }
        return csgs[i - 1].reTesselated().canonicalized();
      },
      unionSub: function(csg, retesselate2, canonicalize2) {
        if (!this.mayOverlap(csg)) {
          return this.unionForNonIntersecting(csg);
        } else {
          let a = new Tree(this.polygons);
          let b = new Tree(csg.polygons);
          a.clipTo(b, false);
          b.clipTo(a);
          b.invert();
          b.clipTo(a);
          b.invert();
          let newpolygons = a.allPolygons().concat(b.allPolygons());
          let result = fromPolygons(newpolygons);
          result.properties = this.properties._merge(csg.properties);
          if (retesselate2) result = result.reTesselated();
          if (canonicalize2) result = result.canonicalized();
          return result;
        }
      },
      // Like union, but when we know that the two solids are not intersecting
      // Do not use if you are not completely sure that the solids do not intersect!
      unionForNonIntersecting: function(csg) {
        let newpolygons = this.polygons.concat(csg.polygons);
        let result = fromPolygons(newpolygons);
        result.properties = this.properties._merge(csg.properties);
        result.isCanonicalized = this.isCanonicalized && csg.isCanonicalized;
        result.isRetesselated = this.isRetesselated && csg.isRetesselated;
        return result;
      },
      /**
       * Return a new CSG solid representing space in this solid but
       * not in the given solids. Neither this solid nor the given solids are modified.
       * @param {CSG[]} csg - list of CSG objects
       * @returns {CSG} new CSG object
       * @example
       * let C = A.subtract(B)
       * @example
       * +-------+            +-------+
       * |       |            |       |
       * |   A   |            |       |
       * |    +--+----+   =   |    +--+
       * +----+--+    |       +----+
       *      |   B   |
       *      |       |
       *      +-------+
       */
      subtract: function(csg) {
        let csgs;
        if (csg instanceof Array) {
          csgs = csg;
        } else {
          csgs = [csg];
        }
        let result = this;
        for (let i = 0; i < csgs.length; i++) {
          let islast = i === csgs.length - 1;
          result = result.subtractSub(csgs[i], islast, islast);
        }
        return result;
      },
      subtractSub: function(csg, retesselate2, canonicalize2) {
        let a = new Tree(this.polygons);
        let b = new Tree(csg.polygons);
        a.invert();
        a.clipTo(b);
        b.clipTo(a, true);
        a.addPolygons(b.allPolygons());
        a.invert();
        let result = fromPolygons(a.allPolygons());
        result.properties = this.properties._merge(csg.properties);
        if (retesselate2) result = result.reTesselated();
        if (canonicalize2) result = result.canonicalized();
        return result;
      },
      /**
       * Return a new CSG solid representing space in both this solid and
       * in the given solids. Neither this solid nor the given solids are modified.
       * @param {CSG[]} csg - list of CSG objects
       * @returns {CSG} new CSG object
       * @example
       * let C = A.intersect(B)
       * @example
       * +-------+
       * |       |
       * |   A   |
       * |    +--+----+   =   +--+
       * +----+--+    |       +--+
       *      |   B   |
       *      |       |
       *      +-------+
       */
      intersect: function(csg) {
        let csgs;
        if (csg instanceof Array) {
          csgs = csg;
        } else {
          csgs = [csg];
        }
        let result = this;
        for (let i = 0; i < csgs.length; i++) {
          let islast = i === csgs.length - 1;
          result = result.intersectSub(csgs[i], islast, islast);
        }
        return result;
      },
      intersectSub: function(csg, retesselate2, canonicalize2) {
        let a = new Tree(this.polygons);
        let b = new Tree(csg.polygons);
        a.invert();
        b.clipTo(a);
        b.invert();
        a.clipTo(b);
        b.clipTo(a);
        a.addPolygons(b.allPolygons());
        a.invert();
        let result = fromPolygons(a.allPolygons());
        result.properties = this.properties._merge(csg.properties);
        if (retesselate2) result = result.reTesselated();
        if (canonicalize2) result = result.canonicalized();
        return result;
      },
      /**
       * Return a new CSG solid with solid and empty space switched.
       * This solid is not modified.
       * @returns {CSG} new CSG object
       * @example
       * let B = A.invert()
       */
      invert: function() {
        let flippedpolygons = this.polygons.map(function(p) {
          return p.flipped();
        });
        return fromPolygons(flippedpolygons);
      },
      // Affine transformation of CSG object. Returns a new CSG object
      transform1: function(matrix4x4) {
        let newpolygons = this.polygons.map(function(p) {
          return p.transform(matrix4x4);
        });
        let result = fromPolygons(newpolygons);
        result.properties = this.properties._transform(matrix4x4);
        result.isRetesselated = this.isRetesselated;
        return result;
      },
      /**
       * Return a new CSG solid that is transformed using the given Matrix.
       * Several matrix transformations can be combined before transforming this solid.
       * @param {CSG.Matrix4x4} matrix4x4 - matrix to be applied
       * @returns {CSG} new CSG object
       * @example
       * var m = new CSG.Matrix4x4()
       * m = m.multiply(CSG.Matrix4x4.rotationX(40))
       * m = m.multiply(CSG.Matrix4x4.translation([-.5, 0, 0]))
       * let B = A.transform(m)
       */
      transform: function(matrix4x4) {
        let ismirror = matrix4x4.isMirroring();
        let transformedvertices = {};
        let transformedplanes = {};
        let newpolygons = this.polygons.map(function(p) {
          let newplane;
          let plane = p.plane;
          let planetag = plane.getTag();
          if (planetag in transformedplanes) {
            newplane = transformedplanes[planetag];
          } else {
            newplane = plane.transform(matrix4x4);
            transformedplanes[planetag] = newplane;
          }
          let newvertices = p.vertices.map(function(v) {
            let newvertex;
            let vertextag = v.getTag();
            if (vertextag in transformedvertices) {
              newvertex = transformedvertices[vertextag];
            } else {
              newvertex = v.transform(matrix4x4);
              transformedvertices[vertextag] = newvertex;
            }
            return newvertex;
          });
          if (ismirror) newvertices.reverse();
          return new Polygon(newvertices, p.shared, newplane);
        });
        let result = fromPolygons(newpolygons);
        result.properties = this.properties._transform(matrix4x4);
        result.isRetesselated = this.isRetesselated;
        result.isCanonicalized = this.isCanonicalized;
        return result;
      },
      // ALIAS !
      center: function(axes) {
        return center({ axes }, [this]);
      },
      // ALIAS !
      expand: function(radius, resolution) {
        return expand(this, radius, resolution);
      },
      // ALIAS !
      contract: function(radius, resolution) {
        return contract(this, radius, resolution);
      },
      // ALIAS !
      expandedShell: function(radius, resolution, unionWithThis) {
        return expandedShellOfCCSG(this, radius, resolution, unionWithThis);
      },
      // cut the solid at a plane, and stretch the cross-section found along plane normal
      // note: only used in roundedCube() internally
      stretchAtPlane: function(normal, point, length) {
        let plane = Plane.fromNormalAndPoint(normal, point);
        let onb = new OrthoNormalBasis(plane);
        let crosssect = this.sectionCut(onb);
        let midpiece = crosssect.extrudeInOrthonormalBasis(onb, length);
        let piece1 = this.cutByPlane(plane);
        let piece2 = this.cutByPlane(plane.flipped());
        let result = piece1.union([midpiece, piece2.translate(plane.normal.times(length))]);
        return result;
      },
      // ALIAS !
      canonicalized: function() {
        return canonicalize(this);
      },
      // ALIAS !
      reTesselated: function() {
        return retesselate(this);
      },
      // ALIAS !
      fixTJunctions: function() {
        return fixTJunctions(fromPolygons, this);
      },
      // ALIAS !
      getBounds: function() {
        return bounds(this);
      },
      /** returns true if there is a possibility that the two solids overlap
       * returns false if we can be sure that they do not overlap
       * NOTE: this is critical as it is used in UNIONs
       * @param  {CSG} csg
       */
      mayOverlap: function(csg) {
        if (this.polygons.length === 0 || csg.polygons.length === 0) {
          return false;
        } else {
          let mybounds = bounds(this);
          let otherbounds = bounds(csg);
          if (mybounds[1].x < otherbounds[0].x) return false;
          if (mybounds[0].x > otherbounds[1].x) return false;
          if (mybounds[1].y < otherbounds[0].y) return false;
          if (mybounds[0].y > otherbounds[1].y) return false;
          if (mybounds[1].z < otherbounds[0].z) return false;
          if (mybounds[0].z > otherbounds[1].z) return false;
          return true;
        }
      },
      // ALIAS !
      cutByPlane: function(plane) {
        return cutByPlane(this, plane);
      },
      /**
       * Connect a solid to another solid, such that two Connectors become connected
       * @param  {Connector} myConnector a Connector of this solid
       * @param  {Connector} otherConnector a Connector to which myConnector should be connected
       * @param  {Boolean} mirror false: the 'axis' vectors of the connectors should point in the same direction
       * true: the 'axis' vectors of the connectors should point in opposite direction
       * @param  {Float} normalrotation degrees of rotation between the 'normal' vectors of the two
       * connectors
       * @returns {CSG} this csg, tranformed accordingly
       */
      connectTo: function(myConnector, otherConnector, mirror, normalrotation) {
        let matrix = myConnector.getTransformationTo(otherConnector, mirror, normalrotation);
        return this.transform(matrix);
      },
      /**
       * set the .shared property of all polygons
       * @param  {Object} shared
       * @returns {CSG} Returns a new CSG solid, the original is unmodified!
       */
      setShared: function(shared) {
        let polygons = this.polygons.map(function(p) {
          return new Polygon(p.vertices, shared, p.plane);
        });
        let result = fromPolygons(polygons);
        result.properties = this.properties;
        result.isRetesselated = this.isRetesselated;
        result.isCanonicalized = this.isCanonicalized;
        return result;
      },
      /** sets the color of this csg: non mutating, returns a new CSG
       * @param  {Object} args
       * @returns {CSG} a copy of this CSG, with the given color
       */
      setColor: function(args) {
        let newshared = Polygon.Shared.fromColor.apply(this, arguments);
        return this.setShared(newshared);
      },
      // ALIAS !
      getTransformationAndInverseTransformationToFlatLying: function() {
        return getTransformationAndInverseTransformationToFlatLying(this);
      },
      // ALIAS !
      getTransformationToFlatLying: function() {
        return getTransformationToFlatLying(this);
      },
      // ALIAS !
      lieFlat: function() {
        return lieFlat(this);
      },
      // project the 3D CSG onto a plane
      // This returns a 2D CAG with the 'shadow' shape of the 3D solid when projected onto the
      // plane represented by the orthonormal basis
      projectToOrthoNormalBasis: function(orthobasis) {
        return projectToOrthoNormalBasis(this, orthobasis);
      },
      // FIXME: not finding any uses within our code ?
      sectionCut: function(orthobasis) {
        return sectionCut(this, orthobasis);
      },
      /**
       * Returns an array of values for the requested features of this solid.
       * Supported Features: 'volume', 'area'
       * @param {String[]} features - list of features to calculate
       * @returns {Float[]} values
       * @example
       * let volume = A.getFeatures('volume')
       * let values = A.getFeatures('area','volume')
       */
      getFeatures: function(features) {
        if (!(features instanceof Array)) {
          features = [features];
        }
        let result = this.toTriangles().map(function(triPoly) {
          return triPoly.getTetraFeatures(features);
        }).reduce(function(pv, v) {
          return v.map(function(feat, i) {
            return feat + (pv === 0 ? 0 : pv[i]);
          });
        }, 0);
        return result.length === 1 ? result[0] : result;
      },
      /** @return {Polygon[]} The list of polygons. */
      toPolygons: function() {
        return this.polygons;
      },
      toString: function() {
        let result = "CSG solid:\n";
        this.polygons.map(function(p) {
          result += p.toString();
        });
        return result;
      },
      /** returns a compact binary representation of this csg
       * usually used to transfer CSG objects to/from webworkes
       * NOTE: very interesting compact format, with a lot of reusable ideas
       * @returns {Object} compact binary representation of a CSG
       */
      toCompactBinary: function() {
        let csg = this.canonicalized();
        let numpolygons = csg.polygons.length;
        let numpolygonvertices = 0;
        let numvertices = 0;
        let vertexmap = {};
        let vertices = [];
        let numplanes = 0;
        let planemap = {};
        let planes = [];
        let shareds = [];
        let sharedmap = {};
        let numshared = 0;
        csg.polygons.map(function(polygon) {
          polygon.vertices.map(function(vertex) {
            ++numpolygonvertices;
            let vertextag = vertex.getTag();
            if (!(vertextag in vertexmap)) {
              vertexmap[vertextag] = numvertices++;
              vertices.push(vertex);
            }
          });
          let planetag = polygon.plane.getTag();
          if (!(planetag in planemap)) {
            planemap[planetag] = numplanes++;
            planes.push(polygon.plane);
          }
          let sharedtag = polygon.shared.getTag();
          if (!(sharedtag in sharedmap)) {
            sharedmap[sharedtag] = numshared++;
            shareds.push(polygon.shared);
          }
        });
        let numVerticesPerPolygon = new Uint32Array(numpolygons);
        let polygonSharedIndexes = new Uint32Array(numpolygons);
        let polygonVertices = new Uint32Array(numpolygonvertices);
        let polygonPlaneIndexes = new Uint32Array(numpolygons);
        let vertexData = new Float64Array(numvertices * 3);
        let planeData = new Float64Array(numplanes * 4);
        let polygonVerticesIndex = 0;
        for (let polygonindex = 0; polygonindex < numpolygons; ++polygonindex) {
          let polygon = csg.polygons[polygonindex];
          numVerticesPerPolygon[polygonindex] = polygon.vertices.length;
          polygon.vertices.map(function(vertex) {
            let vertextag = vertex.getTag();
            let vertexindex = vertexmap[vertextag];
            polygonVertices[polygonVerticesIndex++] = vertexindex;
          });
          let planetag = polygon.plane.getTag();
          let planeindex = planemap[planetag];
          polygonPlaneIndexes[polygonindex] = planeindex;
          let sharedtag = polygon.shared.getTag();
          let sharedindex = sharedmap[sharedtag];
          polygonSharedIndexes[polygonindex] = sharedindex;
        }
        let verticesArrayIndex = 0;
        vertices.map(function(vertex) {
          const pos = vertex.pos;
          vertexData[verticesArrayIndex++] = pos._x;
          vertexData[verticesArrayIndex++] = pos._y;
          vertexData[verticesArrayIndex++] = pos._z;
        });
        let planesArrayIndex = 0;
        planes.map(function(plane) {
          const normal = plane.normal;
          planeData[planesArrayIndex++] = normal._x;
          planeData[planesArrayIndex++] = normal._y;
          planeData[planesArrayIndex++] = normal._z;
          planeData[planesArrayIndex++] = plane.w;
        });
        let result = {
          "class": "CSG",
          numPolygons: numpolygons,
          numVerticesPerPolygon,
          polygonPlaneIndexes,
          polygonSharedIndexes,
          polygonVertices,
          vertexData,
          planeData,
          shared: shareds
        };
        return result;
      },
      /** returns the triangles of this csg
       * @returns {Polygons} triangulated polygons
       */
      toTriangles: function() {
        let polygons = [];
        this.polygons.forEach(function(poly) {
          let firstVertex = poly.vertices[0];
          for (let i = poly.vertices.length - 3; i >= 0; i--) {
            polygons.push(new Polygon(
              [
                firstVertex,
                poly.vertices[i + 1],
                poly.vertices[i + 2]
              ],
              poly.shared,
              poly.plane
            ));
          }
        });
        return polygons;
      }
    };
    module.exports = CSG;
  }
});

// src/core/vendor/csg/src/api/primitives2d.js
var require_primitives2d = __commonJS({
  "src/core/vendor/csg/src/api/primitives2d.js"(exports, module) {
    "use strict";
    var CAG = require_CAG();
    var { parseOptionAs2DVector, parseOptionAsFloat, parseOptionAsInt } = require_optionParsers();
    var { defaultResolution2D } = require_constants();
    var Vector2D = require_Vector2();
    var Vertex2 = require_Vertex2();
    var Path2D = require_Path2();
    var { fromCompactBinary, fromPoints, fromPath2, fromSides } = require_CAGFactories();
    var circle = function(options) {
      options = options || {};
      let center = parseOptionAs2DVector(options, "center", [0, 0]);
      let radius = parseOptionAsFloat(options, "radius", 1);
      let resolution = parseOptionAsInt(options, "resolution", defaultResolution2D);
      let points = [];
      for (let i = 0; i < resolution; i++) {
        let radians = 2 * Math.PI * i / resolution;
        let point = Vector2D.fromAngleRadians(radians).times(radius).plus(center);
        points.push(point);
      }
      return fromPoints(points);
    };
    var ellipse = function(options) {
      options = options || {};
      let c = parseOptionAs2DVector(options, "center", [0, 0]);
      let r = parseOptionAs2DVector(options, "radius", [1, 1]);
      r = r.abs();
      let res = parseOptionAsInt(options, "resolution", defaultResolution2D);
      let e2 = new Path2D([[c.x, c.y + r.y]]);
      e2 = e2.appendArc([c.x, c.y - r.y], {
        xradius: r.x,
        yradius: r.y,
        xaxisrotation: 0,
        resolution: res,
        clockwise: true,
        large: false
      });
      e2 = e2.appendArc([c.x, c.y + r.y], {
        xradius: r.x,
        yradius: r.y,
        xaxisrotation: 0,
        resolution: res,
        clockwise: true,
        large: false
      });
      e2 = e2.close();
      return fromPath2(e2);
    };
    var rectangle = function(options) {
      options = options || {};
      let c, r;
      if ("corner1" in options || "corner2" in options) {
        if ("center" in options || "radius" in options) {
          throw new Error("rectangle: should either give a radius and center parameter, or a corner1 and corner2 parameter");
        }
        let corner1 = parseOptionAs2DVector(options, "corner1", [0, 0]);
        let corner2 = parseOptionAs2DVector(options, "corner2", [1, 1]);
        c = corner1.plus(corner2).times(0.5);
        r = corner2.minus(corner1).times(0.5);
      } else {
        c = parseOptionAs2DVector(options, "center", [0, 0]);
        r = parseOptionAs2DVector(options, "radius", [1, 1]);
      }
      r = r.abs();
      let rswap = new Vector2D(r.x, -r.y);
      let points = [
        c.plus(r),
        c.plus(rswap),
        c.minus(r),
        c.minus(rswap)
      ];
      return fromPoints(points);
    };
    var roundedRectangle = function(options) {
      options = options || {};
      let center, radius;
      if ("corner1" in options || "corner2" in options) {
        if ("center" in options || "radius" in options) {
          throw new Error("roundedRectangle: should either give a radius and center parameter, or a corner1 and corner2 parameter");
        }
        let corner1 = parseOptionAs2DVector(options, "corner1", [0, 0]);
        let corner2 = parseOptionAs2DVector(options, "corner2", [1, 1]);
        center = corner1.plus(corner2).times(0.5);
        radius = corner2.minus(corner1).times(0.5);
      } else {
        center = parseOptionAs2DVector(options, "center", [0, 0]);
        radius = parseOptionAs2DVector(options, "radius", [1, 1]);
      }
      radius = radius.abs();
      let roundradius = parseOptionAsFloat(options, "roundradius", 0.2);
      let resolution = parseOptionAsInt(options, "resolution", defaultResolution2D);
      let maxroundradius = Math.min(radius.x, radius.y);
      maxroundradius -= 0.1;
      roundradius = Math.min(roundradius, maxroundradius);
      roundradius = Math.max(0, roundradius);
      radius = new Vector2D(radius.x - roundradius, radius.y - roundradius);
      let rect = rectangle({
        center,
        radius
      });
      if (roundradius > 0) {
        rect = rect.expand(roundradius, resolution);
      }
      return rect;
    };
    module.exports = {
      circle,
      ellipse,
      rectangle,
      roundedRectangle,
      fromCompactBinary
    };
  }
});

// src/core/vendor/csg/src/api/primitives3d.js
var require_primitives3d = __commonJS({
  "src/core/vendor/csg/src/api/primitives3d.js"(exports, module) {
    "use strict";
    var { parseOption, parseOptionAs3DVector, parseOptionAs2DVector, parseOptionAs3DVectorList, parseOptionAsFloat, parseOptionAsInt } = require_optionParsers();
    var { defaultResolution3D, defaultResolution2D, EPS } = require_constants();
    var Vector3 = require_Vector3();
    var Vertex3 = require_Vertex3();
    var Polygon3 = require_Polygon3();
    var { Connector } = require_connectors();
    var Properties = require_Properties();
    var { fromPolygons } = require_CSGFactories();
    var cube = function(options) {
      let c;
      let r;
      let corner1;
      let corner2;
      options = options || {};
      if ("corner1" in options || "corner2" in options) {
        if ("center" in options || "radius" in options) {
          throw new Error("cube: should either give a radius and center parameter, or a corner1 and corner2 parameter");
        }
        corner1 = parseOptionAs3DVector(options, "corner1", [0, 0, 0]);
        corner2 = parseOptionAs3DVector(options, "corner2", [1, 1, 1]);
        c = corner1.plus(corner2).times(0.5);
        r = corner2.minus(corner1).times(0.5);
      } else {
        c = parseOptionAs3DVector(options, "center", [0, 0, 0]);
        r = parseOptionAs3DVector(options, "radius", [1, 1, 1]);
      }
      r = r.abs();
      let result = fromPolygons([
        [
          [0, 4, 6, 2],
          [-1, 0, 0]
        ],
        [
          [1, 3, 7, 5],
          [1, 0, 0]
        ],
        [
          [0, 1, 5, 4],
          [0, -1, 0]
        ],
        [
          [2, 6, 7, 3],
          [0, 1, 0]
        ],
        [
          [0, 2, 3, 1],
          [0, 0, -1]
        ],
        [
          [4, 5, 7, 6],
          [0, 0, 1]
        ]
      ].map(function(info) {
        let vertices = info[0].map(function(i) {
          let pos = new Vector3(
            c.x + r.x * (2 * !!(i & 1) - 1),
            c.y + r.y * (2 * !!(i & 2) - 1),
            c.z + r.z * (2 * !!(i & 4) - 1)
          );
          return new Vertex3(pos);
        });
        return new Polygon3(
          vertices,
          null
          /* , plane */
        );
      }));
      result.properties.cube = new Properties();
      result.properties.cube.center = new Vector3(c);
      result.properties.cube.facecenters = [
        new Connector(new Vector3([r.x, 0, 0]).plus(c), [1, 0, 0], [0, 0, 1]),
        new Connector(new Vector3([-r.x, 0, 0]).plus(c), [-1, 0, 0], [0, 0, 1]),
        new Connector(new Vector3([0, r.y, 0]).plus(c), [0, 1, 0], [0, 0, 1]),
        new Connector(new Vector3([0, -r.y, 0]).plus(c), [0, -1, 0], [0, 0, 1]),
        new Connector(new Vector3([0, 0, r.z]).plus(c), [0, 0, 1], [1, 0, 0]),
        new Connector(new Vector3([0, 0, -r.z]).plus(c), [0, 0, -1], [1, 0, 0])
      ];
      return result;
    };
    var sphere = function(options) {
      options = options || {};
      let center = parseOptionAs3DVector(options, "center", [0, 0, 0]);
      let radius = parseOptionAsFloat(options, "radius", 1);
      let resolution = parseOptionAsInt(options, "resolution", defaultResolution3D);
      let xvector, yvector, zvector;
      if ("axes" in options) {
        xvector = options.axes[0].unit().times(radius);
        yvector = options.axes[1].unit().times(radius);
        zvector = options.axes[2].unit().times(radius);
      } else {
        xvector = new Vector3([1, 0, 0]).times(radius);
        yvector = new Vector3([0, -1, 0]).times(radius);
        zvector = new Vector3([0, 0, 1]).times(radius);
      }
      if (resolution < 4) resolution = 4;
      let qresolution = Math.round(resolution / 4);
      let prevcylinderpoint;
      let polygons = [];
      for (let slice1 = 0; slice1 <= resolution; slice1++) {
        let angle = Math.PI * 2 * slice1 / resolution;
        let cylinderpoint = xvector.times(Math.cos(angle)).plus(yvector.times(Math.sin(angle)));
        if (slice1 > 0) {
          let vertices = [];
          let prevcospitch, prevsinpitch;
          for (let slice2 = 0; slice2 <= qresolution; slice2++) {
            let pitch = 0.5 * Math.PI * slice2 / qresolution;
            let cospitch = Math.cos(pitch);
            let sinpitch = Math.sin(pitch);
            if (slice2 > 0) {
              vertices = [];
              vertices.push(new Vertex3(center.plus(prevcylinderpoint.times(prevcospitch).minus(zvector.times(prevsinpitch)))));
              vertices.push(new Vertex3(center.plus(cylinderpoint.times(prevcospitch).minus(zvector.times(prevsinpitch)))));
              if (slice2 < qresolution) {
                vertices.push(new Vertex3(center.plus(cylinderpoint.times(cospitch).minus(zvector.times(sinpitch)))));
              }
              vertices.push(new Vertex3(center.plus(prevcylinderpoint.times(cospitch).minus(zvector.times(sinpitch)))));
              polygons.push(new Polygon3(vertices));
              vertices = [];
              vertices.push(new Vertex3(center.plus(prevcylinderpoint.times(prevcospitch).plus(zvector.times(prevsinpitch)))));
              vertices.push(new Vertex3(center.plus(cylinderpoint.times(prevcospitch).plus(zvector.times(prevsinpitch)))));
              if (slice2 < qresolution) {
                vertices.push(new Vertex3(center.plus(cylinderpoint.times(cospitch).plus(zvector.times(sinpitch)))));
              }
              vertices.push(new Vertex3(center.plus(prevcylinderpoint.times(cospitch).plus(zvector.times(sinpitch)))));
              vertices.reverse();
              polygons.push(new Polygon3(vertices));
            }
            prevcospitch = cospitch;
            prevsinpitch = sinpitch;
          }
        }
        prevcylinderpoint = cylinderpoint;
      }
      let result = fromPolygons(polygons);
      result.properties.sphere = new Properties();
      result.properties.sphere.center = new Vector3(center);
      result.properties.sphere.facepoint = center.plus(xvector);
      return result;
    };
    var cylinder = function(options) {
      let s = parseOptionAs3DVector(options, "start", [0, -1, 0]);
      let e = parseOptionAs3DVector(options, "end", [0, 1, 0]);
      let r = parseOptionAsFloat(options, "radius", 1);
      let rEnd = parseOptionAsFloat(options, "radiusEnd", r);
      let rStart = parseOptionAsFloat(options, "radiusStart", r);
      let alpha = parseOptionAsFloat(options, "sectorAngle", 360);
      alpha = alpha > 360 ? alpha % 360 : alpha;
      if (rEnd < 0 || rStart < 0) {
        throw new Error("Radius should be non-negative");
      }
      if (rEnd === 0 && rStart === 0) {
        throw new Error("Either radiusStart or radiusEnd should be positive");
      }
      let slices = parseOptionAsInt(options, "resolution", defaultResolution2D);
      let ray = e.minus(s);
      let axisZ = ray.unit();
      let axisX = axisZ.randomNonParallelVector().unit();
      let axisY = axisX.cross(axisZ).unit();
      let start = new Vertex3(s);
      let end = new Vertex3(e);
      let polygons = [];
      function point(stack, slice, radius) {
        let angle = slice * Math.PI * alpha / 180;
        let out = axisX.times(Math.cos(angle)).plus(axisY.times(Math.sin(angle)));
        let pos = s.plus(ray.times(stack)).plus(out.times(radius));
        return new Vertex3(pos);
      }
      if (alpha > 0) {
        for (let i = 0; i < slices; i++) {
          let t0 = i / slices;
          let t1 = (i + 1) / slices;
          if (rEnd === rStart) {
            polygons.push(new Polygon3([start, point(0, t0, rEnd), point(0, t1, rEnd)]));
            polygons.push(new Polygon3([point(0, t1, rEnd), point(0, t0, rEnd), point(1, t0, rEnd), point(1, t1, rEnd)]));
            polygons.push(new Polygon3([end, point(1, t1, rEnd), point(1, t0, rEnd)]));
          } else {
            if (rStart > 0) {
              polygons.push(new Polygon3([start, point(0, t0, rStart), point(0, t1, rStart)]));
              polygons.push(new Polygon3([point(0, t0, rStart), point(1, t0, rEnd), point(0, t1, rStart)]));
            }
            if (rEnd > 0) {
              polygons.push(new Polygon3([end, point(1, t1, rEnd), point(1, t0, rEnd)]));
              polygons.push(new Polygon3([point(1, t0, rEnd), point(1, t1, rEnd), point(0, t1, rStart)]));
            }
          }
        }
        if (alpha < 360) {
          polygons.push(new Polygon3([start, end, point(0, 0, rStart)]));
          polygons.push(new Polygon3([point(0, 0, rStart), end, point(1, 0, rEnd)]));
          polygons.push(new Polygon3([start, point(0, 1, rStart), end]));
          polygons.push(new Polygon3([point(0, 1, rStart), point(1, 1, rEnd), end]));
        }
      }
      let result = fromPolygons(polygons);
      result.properties.cylinder = new Properties();
      result.properties.cylinder.start = new Connector(s, axisZ.negated(), axisX);
      result.properties.cylinder.end = new Connector(e, axisZ, axisX);
      let cylCenter = s.plus(ray.times(0.5));
      let fptVec = axisX.rotate(s, axisZ, -alpha / 2).times((rStart + rEnd) / 2);
      let fptVec90 = fptVec.cross(axisZ);
      result.properties.cylinder.facepointH = new Connector(cylCenter.plus(fptVec), fptVec, axisZ);
      result.properties.cylinder.facepointH90 = new Connector(cylCenter.plus(fptVec90), fptVec90, axisZ);
      return result;
    };
    var roundedCylinder = function(options) {
      let p1 = parseOptionAs3DVector(options, "start", [0, -1, 0]);
      let p2 = parseOptionAs3DVector(options, "end", [0, 1, 0]);
      let radius = parseOptionAsFloat(options, "radius", 1);
      let direction = p2.minus(p1);
      let defaultnormal;
      if (Math.abs(direction.x) > Math.abs(direction.y)) {
        defaultnormal = new Vector3(0, 1, 0);
      } else {
        defaultnormal = new Vector3(1, 0, 0);
      }
      let normal = parseOptionAs3DVector(options, "normal", defaultnormal);
      let resolution = parseOptionAsInt(options, "resolution", defaultResolution3D);
      if (resolution < 4) resolution = 4;
      let polygons = [];
      let qresolution = Math.floor(0.25 * resolution);
      let length = direction.length();
      if (length < EPS) {
        return sphere({
          center: p1,
          radius,
          resolution
        });
      }
      let zvector = direction.unit().times(radius);
      let xvector = zvector.cross(normal).unit().times(radius);
      let yvector = xvector.cross(zvector).unit().times(radius);
      let prevcylinderpoint;
      for (let slice1 = 0; slice1 <= resolution; slice1++) {
        let angle = Math.PI * 2 * slice1 / resolution;
        let cylinderpoint = xvector.times(Math.cos(angle)).plus(yvector.times(Math.sin(angle)));
        if (slice1 > 0) {
          let vertices = [];
          vertices.push(new Vertex3(p1.plus(cylinderpoint)));
          vertices.push(new Vertex3(p1.plus(prevcylinderpoint)));
          vertices.push(new Vertex3(p2.plus(prevcylinderpoint)));
          vertices.push(new Vertex3(p2.plus(cylinderpoint)));
          polygons.push(new Polygon3(vertices));
          let prevcospitch, prevsinpitch;
          for (let slice2 = 0; slice2 <= qresolution; slice2++) {
            let pitch = 0.5 * Math.PI * slice2 / qresolution;
            let cospitch = Math.cos(pitch);
            let sinpitch = Math.sin(pitch);
            if (slice2 > 0) {
              vertices = [];
              vertices.push(new Vertex3(p1.plus(prevcylinderpoint.times(prevcospitch).minus(zvector.times(prevsinpitch)))));
              vertices.push(new Vertex3(p1.plus(cylinderpoint.times(prevcospitch).minus(zvector.times(prevsinpitch)))));
              if (slice2 < qresolution) {
                vertices.push(new Vertex3(p1.plus(cylinderpoint.times(cospitch).minus(zvector.times(sinpitch)))));
              }
              vertices.push(new Vertex3(p1.plus(prevcylinderpoint.times(cospitch).minus(zvector.times(sinpitch)))));
              polygons.push(new Polygon3(vertices));
              vertices = [];
              vertices.push(new Vertex3(p2.plus(prevcylinderpoint.times(prevcospitch).plus(zvector.times(prevsinpitch)))));
              vertices.push(new Vertex3(p2.plus(cylinderpoint.times(prevcospitch).plus(zvector.times(prevsinpitch)))));
              if (slice2 < qresolution) {
                vertices.push(new Vertex3(p2.plus(cylinderpoint.times(cospitch).plus(zvector.times(sinpitch)))));
              }
              vertices.push(new Vertex3(p2.plus(prevcylinderpoint.times(cospitch).plus(zvector.times(sinpitch)))));
              vertices.reverse();
              polygons.push(new Polygon3(vertices));
            }
            prevcospitch = cospitch;
            prevsinpitch = sinpitch;
          }
        }
        prevcylinderpoint = cylinderpoint;
      }
      let result = fromPolygons(polygons);
      let ray = zvector.unit();
      let axisX = xvector.unit();
      result.properties.roundedCylinder = new Properties();
      result.properties.roundedCylinder.start = new Connector(p1, ray.negated(), axisX);
      result.properties.roundedCylinder.end = new Connector(p2, ray, axisX);
      result.properties.roundedCylinder.facepoint = p1.plus(xvector);
      return result;
    };
    var cylinderElliptic = function(options) {
      let s = parseOptionAs3DVector(options, "start", [0, -1, 0]);
      let e = parseOptionAs3DVector(options, "end", [0, 1, 0]);
      let r = parseOptionAs2DVector(options, "radius", [1, 1]);
      let rEnd = parseOptionAs2DVector(options, "radiusEnd", r);
      let rStart = parseOptionAs2DVector(options, "radiusStart", r);
      if (rEnd._x < 0 || rStart._x < 0 || rEnd._y < 0 || rStart._y < 0) {
        throw new Error("Radius should be non-negative");
      }
      if ((rEnd._x === 0 || rEnd._y === 0) && (rStart._x === 0 || rStart._y === 0)) {
        throw new Error("Either radiusStart or radiusEnd should be positive");
      }
      let slices = parseOptionAsInt(options, "resolution", defaultResolution2D);
      let ray = e.minus(s);
      let axisZ = ray.unit();
      let axisX = axisZ.randomNonParallelVector().unit();
      let axisY = axisX.cross(axisZ).unit();
      let start = new Vertex3(s);
      let end = new Vertex3(e);
      let polygons = [];
      function point(stack, slice, radius) {
        let angle = slice * Math.PI * 2;
        let out = axisX.times(radius._x * Math.cos(angle)).plus(axisY.times(radius._y * Math.sin(angle)));
        let pos = s.plus(ray.times(stack)).plus(out);
        return new Vertex3(pos);
      }
      for (let i = 0; i < slices; i++) {
        let t0 = i / slices;
        let t1 = (i + 1) / slices;
        if (rEnd._x === rStart._x && rEnd._y === rStart._y) {
          polygons.push(new Polygon3([start, point(0, t0, rEnd), point(0, t1, rEnd)]));
          polygons.push(new Polygon3([point(0, t1, rEnd), point(0, t0, rEnd), point(1, t0, rEnd), point(1, t1, rEnd)]));
          polygons.push(new Polygon3([end, point(1, t1, rEnd), point(1, t0, rEnd)]));
        } else {
          if (rStart._x > 0) {
            polygons.push(new Polygon3([start, point(0, t0, rStart), point(0, t1, rStart)]));
            polygons.push(new Polygon3([point(0, t0, rStart), point(1, t0, rEnd), point(0, t1, rStart)]));
          }
          if (rEnd._x > 0) {
            polygons.push(new Polygon3([end, point(1, t1, rEnd), point(1, t0, rEnd)]));
            polygons.push(new Polygon3([point(1, t0, rEnd), point(1, t1, rEnd), point(0, t1, rStart)]));
          }
        }
      }
      let result = fromPolygons(polygons);
      result.properties.cylinder = new Properties();
      result.properties.cylinder.start = new Connector(s, axisZ.negated(), axisX);
      result.properties.cylinder.end = new Connector(e, axisZ, axisX);
      result.properties.cylinder.facepoint = s.plus(axisX.times(rStart));
      return result;
    };
    var roundedCube = function(options) {
      let minRR = 0.01;
      let center;
      let cuberadius;
      let corner1;
      let corner2;
      options = options || {};
      if ("corner1" in options || "corner2" in options) {
        if ("center" in options || "radius" in options) {
          throw new Error("roundedCube: should either give a radius and center parameter, or a corner1 and corner2 parameter");
        }
        corner1 = parseOptionAs3DVector(options, "corner1", [0, 0, 0]);
        corner2 = parseOptionAs3DVector(options, "corner2", [1, 1, 1]);
        center = corner1.plus(corner2).times(0.5);
        cuberadius = corner2.minus(corner1).times(0.5);
      } else {
        center = parseOptionAs3DVector(options, "center", [0, 0, 0]);
        cuberadius = parseOptionAs3DVector(options, "radius", [1, 1, 1]);
      }
      cuberadius = cuberadius.abs();
      let resolution = parseOptionAsInt(options, "resolution", defaultResolution3D);
      if (resolution < 4) resolution = 4;
      if (resolution % 2 === 1 && resolution < 8) resolution = 8;
      let roundradius = parseOptionAs3DVector(options, "roundradius", [0.2, 0.2, 0.2]);
      roundradius = Vector3.Create(Math.max(roundradius.x, minRR), Math.max(roundradius.y, minRR), Math.max(roundradius.z, minRR));
      let innerradius = cuberadius.minus(roundradius);
      if (innerradius.x < 0 || innerradius.y < 0 || innerradius.z < 0) {
        throw new Error("roundradius <= radius!");
      }
      let res = sphere({ radius: 1, resolution });
      res = res.scale(roundradius);
      innerradius.x > EPS && (res = res.stretchAtPlane([1, 0, 0], [0, 0, 0], 2 * innerradius.x));
      innerradius.y > EPS && (res = res.stretchAtPlane([0, 1, 0], [0, 0, 0], 2 * innerradius.y));
      innerradius.z > EPS && (res = res.stretchAtPlane([0, 0, 1], [0, 0, 0], 2 * innerradius.z));
      res = res.translate([-innerradius.x + center.x, -innerradius.y + center.y, -innerradius.z + center.z]);
      res = res.reTesselated();
      res.properties.roundedCube = new Properties();
      res.properties.roundedCube.center = new Vertex3(center);
      res.properties.roundedCube.facecenters = [
        new Connector(new Vector3([cuberadius.x, 0, 0]).plus(center), [1, 0, 0], [0, 0, 1]),
        new Connector(new Vector3([-cuberadius.x, 0, 0]).plus(center), [-1, 0, 0], [0, 0, 1]),
        new Connector(new Vector3([0, cuberadius.y, 0]).plus(center), [0, 1, 0], [0, 0, 1]),
        new Connector(new Vector3([0, -cuberadius.y, 0]).plus(center), [0, -1, 0], [0, 0, 1]),
        new Connector(new Vector3([0, 0, cuberadius.z]).plus(center), [0, 0, 1], [1, 0, 0]),
        new Connector(new Vector3([0, 0, -cuberadius.z]).plus(center), [0, 0, -1], [1, 0, 0])
      ];
      return res;
    };
    var polyhedron = function(options) {
      options = options || {};
      if ("points" in options !== "faces" in options) {
        throw new Error("polyhedron needs 'points' and 'faces' arrays");
      }
      let vertices = parseOptionAs3DVectorList(options, "points", [
        [1, 1, 0],
        [1, -1, 0],
        [-1, -1, 0],
        [-1, 1, 0],
        [0, 0, 1]
      ]).map(function(pt) {
        return new Vertex3(pt);
      });
      let faces = parseOption(options, "faces", [
        [0, 1, 4],
        [1, 2, 4],
        [2, 3, 4],
        [3, 0, 4],
        [1, 0, 3],
        [2, 1, 3]
      ]);
      faces.forEach(function(face) {
        face.reverse();
      });
      let polygons = faces.map(function(face) {
        return new Polygon3(face.map(function(idx) {
          return vertices[idx];
        }));
      });
      return fromPolygons(polygons).reTesselated();
    };
    module.exports = {
      cube,
      sphere,
      roundedCube,
      cylinder,
      roundedCylinder,
      cylinderElliptic,
      polyhedron
    };
  }
});

// src/core/vendor/csg/src/api/debugHelpers.js
var require_debugHelpers = __commonJS({
  "src/core/vendor/csg/src/api/debugHelpers.js"(exports, module) {
    "use strict";
    var CSG = require_CSG();
    var { cube } = require_primitives3d();
    var toPointCloud = function(csg, cuberadius) {
      csg = csg.reTesselated();
      let result = new CSG();
      let vertexmap = {};
      csg.polygons.map(function(polygon) {
        polygon.vertices.map(function(vertex) {
          vertexmap[vertex.getTag()] = vertex.pos;
        });
      });
      for (let vertextag in vertexmap) {
        let pos = vertexmap[vertextag];
        let _cube = cube({
          center: pos,
          radius: cuberadius
        });
        result = result.unionSub(_cube, false, false);
      }
      result = result.reTesselated();
      return result;
    };
    module.exports = { toPointCloud };
  }
});

// src/core/vendor/csg/csg.js
var require_csg = __commonJS({
  "src/core/vendor/csg/csg.js"(exports, module) {
    var { addTransformationMethodsToPrototype, addCenteringToPrototype } = require_mutators();
    var CSG = require_CSG();
    var CAG = require_CAG();
    var {
      _CSGDEBUG,
      defaultResolution2D,
      defaultResolution3D,
      EPS,
      angleEPS,
      areaEPS,
      all,
      top,
      bottom,
      left,
      right,
      front,
      back,
      staticTag,
      getTag
    } = require_constants();
    CSG._CSGDEBUG = _CSGDEBUG;
    CSG.defaultResolution2D = defaultResolution2D;
    CSG.defaultResolution3D = defaultResolution3D;
    CSG.EPS = EPS;
    CSG.angleEPS = angleEPS;
    CSG.areaEPS = areaEPS;
    CSG.all = all;
    CSG.top = top;
    CSG.bottom = bottom;
    CSG.left = left;
    CSG.right = right;
    CSG.front = front;
    CSG.back = back;
    CSG.staticTag = staticTag;
    CSG.getTag = getTag;
    CSG.Vector2D = require_Vector2();
    CSG.Vector3D = require_Vector3();
    CSG.Vertex = require_Vertex3();
    CAG.Vertex = require_Vertex2();
    CSG.Plane = require_Plane();
    CSG.Polygon = require_Polygon3();
    CSG.Polygon2D = require_Polygon2();
    CSG.Line2D = require_Line2();
    CSG.Line3D = require_Line3();
    CSG.Path2D = require_Path2();
    CSG.OrthoNormalBasis = require_OrthoNormalBasis();
    CSG.Matrix4x4 = require_Matrix4();
    CAG.Side = require_Side();
    CSG.Connector = require_connectors().Connector;
    CSG.ConnectorList = require_connectors().ConnectorList;
    CSG.Properties = require_Properties();
    var { circle, ellipse, rectangle, roundedRectangle } = require_primitives2d();
    var { sphere, cube, roundedCube, cylinder, roundedCylinder, cylinderElliptic, polyhedron } = require_primitives3d();
    CSG.sphere = sphere;
    CSG.cube = cube;
    CSG.roundedCube = roundedCube;
    CSG.cylinder = cylinder;
    CSG.roundedCylinder = roundedCylinder;
    CSG.cylinderElliptic = cylinderElliptic;
    CSG.polyhedron = polyhedron;
    CAG.circle = circle;
    CAG.ellipse = ellipse;
    CAG.rectangle = rectangle;
    CAG.roundedRectangle = roundedRectangle;
    var { fromPolygons, fromCompactBinary, fromObject, fromSlices } = require_CSGFactories();
    CSG.fromCompactBinary = fromCompactBinary;
    CSG.fromObject = fromObject;
    CSG.fromSlices = fromSlices;
    CSG.fromPolygons = fromPolygons;
    CSG.toPointCloud = require_debugHelpers().toPointCloud;
    var CAGFactories = require_CAGFactories();
    CAG.fromSides = CAGFactories.fromSides;
    CAG.fromObject = CAGFactories.fromObject;
    CAG.fromPoints = CAGFactories.fromPoints;
    CAG.fromPointsNoCheck = CAGFactories.fromPointsNoCheck;
    CAG.fromPath2 = CAGFactories.fromPath2;
    CAG.fromFakeCSG = CAGFactories.fromFakeCSG;
    CAG.fromCompactBinary = CAGFactories.fromCompactBinary;
    var optionsParsers = require_optionParsers();
    addTransformationMethodsToPrototype(CSG.prototype);
    addTransformationMethodsToPrototype(CSG.Vector2D.prototype);
    addTransformationMethodsToPrototype(CSG.Vector3D.prototype);
    addTransformationMethodsToPrototype(CSG.Vertex.prototype);
    addTransformationMethodsToPrototype(CSG.Plane.prototype);
    addTransformationMethodsToPrototype(CSG.Polygon.prototype);
    addTransformationMethodsToPrototype(CSG.Line2D.prototype);
    addTransformationMethodsToPrototype(CSG.Line3D.prototype);
    addTransformationMethodsToPrototype(CSG.Path2D.prototype);
    addTransformationMethodsToPrototype(CSG.OrthoNormalBasis.prototype);
    addTransformationMethodsToPrototype(CSG.Connector.prototype);
    addTransformationMethodsToPrototype(CAG.prototype);
    addTransformationMethodsToPrototype(CAG.Side.prototype);
    addTransformationMethodsToPrototype(CAG.Vertex.prototype);
    CSG.parseOptionAs2DVector = optionsParsers.parseOptionAs3DVector;
    CSG.parseOptionAs3DVector = optionsParsers.parseOptionAs3DVector;
    CSG.parseOptionAs3DVectorList = optionsParsers.parseOptionAs3DVectorList;
    CSG.parseOptionAsBool = optionsParsers.parseOptionAsBool;
    CSG.parseOptionAsFloat = optionsParsers.parseOptionAsFloat;
    CSG.parseOptionAsInt = optionsParsers.parseOptionAsInt;
    CSG.Polygon2D.prototype = CAG.prototype;
    var { isCAG, isCSG } = require_utils();
    var globalApi = Object.assign({}, { CSG, CAG }, optionsParsers, { isCAG, isCSG });
    module.exports = globalApi;
  }
});
export default require_csg();
